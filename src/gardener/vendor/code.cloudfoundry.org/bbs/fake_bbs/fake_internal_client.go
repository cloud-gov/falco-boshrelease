// Code generated by counterfeiter. DO NOT EDIT.
package fake_bbs

import (
	"sync"
	"time"

	"code.cloudfoundry.org/bbs"
	"code.cloudfoundry.org/bbs/events"
	"code.cloudfoundry.org/bbs/models"
	"code.cloudfoundry.org/lager"
)

type FakeInternalClient struct {
	DesireTaskStub        func(logger lager.Logger, guid, domain string, def *models.TaskDefinition) error
	desireTaskMutex       sync.RWMutex
	desireTaskArgsForCall []struct {
		logger lager.Logger
		guid   string
		domain string
		def    *models.TaskDefinition
	}
	desireTaskReturns struct {
		result1 error
	}
	desireTaskReturnsOnCall map[int]struct {
		result1 error
	}
	TasksStub        func(logger lager.Logger) ([]*models.Task, error)
	tasksMutex       sync.RWMutex
	tasksArgsForCall []struct {
		logger lager.Logger
	}
	tasksReturns struct {
		result1 []*models.Task
		result2 error
	}
	tasksReturnsOnCall map[int]struct {
		result1 []*models.Task
		result2 error
	}
	TasksWithFilterStub        func(logger lager.Logger, filter models.TaskFilter) ([]*models.Task, error)
	tasksWithFilterMutex       sync.RWMutex
	tasksWithFilterArgsForCall []struct {
		logger lager.Logger
		filter models.TaskFilter
	}
	tasksWithFilterReturns struct {
		result1 []*models.Task
		result2 error
	}
	tasksWithFilterReturnsOnCall map[int]struct {
		result1 []*models.Task
		result2 error
	}
	TasksByDomainStub        func(logger lager.Logger, domain string) ([]*models.Task, error)
	tasksByDomainMutex       sync.RWMutex
	tasksByDomainArgsForCall []struct {
		logger lager.Logger
		domain string
	}
	tasksByDomainReturns struct {
		result1 []*models.Task
		result2 error
	}
	tasksByDomainReturnsOnCall map[int]struct {
		result1 []*models.Task
		result2 error
	}
	TasksByCellIDStub        func(logger lager.Logger, cellId string) ([]*models.Task, error)
	tasksByCellIDMutex       sync.RWMutex
	tasksByCellIDArgsForCall []struct {
		logger lager.Logger
		cellId string
	}
	tasksByCellIDReturns struct {
		result1 []*models.Task
		result2 error
	}
	tasksByCellIDReturnsOnCall map[int]struct {
		result1 []*models.Task
		result2 error
	}
	TaskByGuidStub        func(logger lager.Logger, guid string) (*models.Task, error)
	taskByGuidMutex       sync.RWMutex
	taskByGuidArgsForCall []struct {
		logger lager.Logger
		guid   string
	}
	taskByGuidReturns struct {
		result1 *models.Task
		result2 error
	}
	taskByGuidReturnsOnCall map[int]struct {
		result1 *models.Task
		result2 error
	}
	CancelTaskStub        func(logger lager.Logger, taskGuid string) error
	cancelTaskMutex       sync.RWMutex
	cancelTaskArgsForCall []struct {
		logger   lager.Logger
		taskGuid string
	}
	cancelTaskReturns struct {
		result1 error
	}
	cancelTaskReturnsOnCall map[int]struct {
		result1 error
	}
	ResolvingTaskStub        func(logger lager.Logger, taskGuid string) error
	resolvingTaskMutex       sync.RWMutex
	resolvingTaskArgsForCall []struct {
		logger   lager.Logger
		taskGuid string
	}
	resolvingTaskReturns struct {
		result1 error
	}
	resolvingTaskReturnsOnCall map[int]struct {
		result1 error
	}
	DeleteTaskStub        func(logger lager.Logger, taskGuid string) error
	deleteTaskMutex       sync.RWMutex
	deleteTaskArgsForCall []struct {
		logger   lager.Logger
		taskGuid string
	}
	deleteTaskReturns struct {
		result1 error
	}
	deleteTaskReturnsOnCall map[int]struct {
		result1 error
	}
	DomainsStub        func(logger lager.Logger) ([]string, error)
	domainsMutex       sync.RWMutex
	domainsArgsForCall []struct {
		logger lager.Logger
	}
	domainsReturns struct {
		result1 []string
		result2 error
	}
	domainsReturnsOnCall map[int]struct {
		result1 []string
		result2 error
	}
	UpsertDomainStub        func(logger lager.Logger, domain string, ttl time.Duration) error
	upsertDomainMutex       sync.RWMutex
	upsertDomainArgsForCall []struct {
		logger lager.Logger
		domain string
		ttl    time.Duration
	}
	upsertDomainReturns struct {
		result1 error
	}
	upsertDomainReturnsOnCall map[int]struct {
		result1 error
	}
	ActualLRPGroupsStub        func(lager.Logger, models.ActualLRPFilter) ([]*models.ActualLRPGroup, error)
	actualLRPGroupsMutex       sync.RWMutex
	actualLRPGroupsArgsForCall []struct {
		arg1 lager.Logger
		arg2 models.ActualLRPFilter
	}
	actualLRPGroupsReturns struct {
		result1 []*models.ActualLRPGroup
		result2 error
	}
	actualLRPGroupsReturnsOnCall map[int]struct {
		result1 []*models.ActualLRPGroup
		result2 error
	}
	ActualLRPGroupsByProcessGuidStub        func(logger lager.Logger, processGuid string) ([]*models.ActualLRPGroup, error)
	actualLRPGroupsByProcessGuidMutex       sync.RWMutex
	actualLRPGroupsByProcessGuidArgsForCall []struct {
		logger      lager.Logger
		processGuid string
	}
	actualLRPGroupsByProcessGuidReturns struct {
		result1 []*models.ActualLRPGroup
		result2 error
	}
	actualLRPGroupsByProcessGuidReturnsOnCall map[int]struct {
		result1 []*models.ActualLRPGroup
		result2 error
	}
	ActualLRPGroupByProcessGuidAndIndexStub        func(logger lager.Logger, processGuid string, index int) (*models.ActualLRPGroup, error)
	actualLRPGroupByProcessGuidAndIndexMutex       sync.RWMutex
	actualLRPGroupByProcessGuidAndIndexArgsForCall []struct {
		logger      lager.Logger
		processGuid string
		index       int
	}
	actualLRPGroupByProcessGuidAndIndexReturns struct {
		result1 *models.ActualLRPGroup
		result2 error
	}
	actualLRPGroupByProcessGuidAndIndexReturnsOnCall map[int]struct {
		result1 *models.ActualLRPGroup
		result2 error
	}
	RetireActualLRPStub        func(logger lager.Logger, key *models.ActualLRPKey) error
	retireActualLRPMutex       sync.RWMutex
	retireActualLRPArgsForCall []struct {
		logger lager.Logger
		key    *models.ActualLRPKey
	}
	retireActualLRPReturns struct {
		result1 error
	}
	retireActualLRPReturnsOnCall map[int]struct {
		result1 error
	}
	DesiredLRPsStub        func(lager.Logger, models.DesiredLRPFilter) ([]*models.DesiredLRP, error)
	desiredLRPsMutex       sync.RWMutex
	desiredLRPsArgsForCall []struct {
		arg1 lager.Logger
		arg2 models.DesiredLRPFilter
	}
	desiredLRPsReturns struct {
		result1 []*models.DesiredLRP
		result2 error
	}
	desiredLRPsReturnsOnCall map[int]struct {
		result1 []*models.DesiredLRP
		result2 error
	}
	DesiredLRPByProcessGuidStub        func(logger lager.Logger, processGuid string) (*models.DesiredLRP, error)
	desiredLRPByProcessGuidMutex       sync.RWMutex
	desiredLRPByProcessGuidArgsForCall []struct {
		logger      lager.Logger
		processGuid string
	}
	desiredLRPByProcessGuidReturns struct {
		result1 *models.DesiredLRP
		result2 error
	}
	desiredLRPByProcessGuidReturnsOnCall map[int]struct {
		result1 *models.DesiredLRP
		result2 error
	}
	DesiredLRPSchedulingInfosStub        func(lager.Logger, models.DesiredLRPFilter) ([]*models.DesiredLRPSchedulingInfo, error)
	desiredLRPSchedulingInfosMutex       sync.RWMutex
	desiredLRPSchedulingInfosArgsForCall []struct {
		arg1 lager.Logger
		arg2 models.DesiredLRPFilter
	}
	desiredLRPSchedulingInfosReturns struct {
		result1 []*models.DesiredLRPSchedulingInfo
		result2 error
	}
	desiredLRPSchedulingInfosReturnsOnCall map[int]struct {
		result1 []*models.DesiredLRPSchedulingInfo
		result2 error
	}
	DesireLRPStub        func(lager.Logger, *models.DesiredLRP) error
	desireLRPMutex       sync.RWMutex
	desireLRPArgsForCall []struct {
		arg1 lager.Logger
		arg2 *models.DesiredLRP
	}
	desireLRPReturns struct {
		result1 error
	}
	desireLRPReturnsOnCall map[int]struct {
		result1 error
	}
	UpdateDesiredLRPStub        func(logger lager.Logger, processGuid string, update *models.DesiredLRPUpdate) error
	updateDesiredLRPMutex       sync.RWMutex
	updateDesiredLRPArgsForCall []struct {
		logger      lager.Logger
		processGuid string
		update      *models.DesiredLRPUpdate
	}
	updateDesiredLRPReturns struct {
		result1 error
	}
	updateDesiredLRPReturnsOnCall map[int]struct {
		result1 error
	}
	RemoveDesiredLRPStub        func(logger lager.Logger, processGuid string) error
	removeDesiredLRPMutex       sync.RWMutex
	removeDesiredLRPArgsForCall []struct {
		logger      lager.Logger
		processGuid string
	}
	removeDesiredLRPReturns struct {
		result1 error
	}
	removeDesiredLRPReturnsOnCall map[int]struct {
		result1 error
	}
	SubscribeToEventsStub        func(logger lager.Logger) (events.EventSource, error)
	subscribeToEventsMutex       sync.RWMutex
	subscribeToEventsArgsForCall []struct {
		logger lager.Logger
	}
	subscribeToEventsReturns struct {
		result1 events.EventSource
		result2 error
	}
	subscribeToEventsReturnsOnCall map[int]struct {
		result1 events.EventSource
		result2 error
	}
	SubscribeToTaskEventsStub        func(logger lager.Logger) (events.EventSource, error)
	subscribeToTaskEventsMutex       sync.RWMutex
	subscribeToTaskEventsArgsForCall []struct {
		logger lager.Logger
	}
	subscribeToTaskEventsReturns struct {
		result1 events.EventSource
		result2 error
	}
	subscribeToTaskEventsReturnsOnCall map[int]struct {
		result1 events.EventSource
		result2 error
	}
	SubscribeToEventsByCellIDStub        func(logger lager.Logger, cellId string) (events.EventSource, error)
	subscribeToEventsByCellIDMutex       sync.RWMutex
	subscribeToEventsByCellIDArgsForCall []struct {
		logger lager.Logger
		cellId string
	}
	subscribeToEventsByCellIDReturns struct {
		result1 events.EventSource
		result2 error
	}
	subscribeToEventsByCellIDReturnsOnCall map[int]struct {
		result1 events.EventSource
		result2 error
	}
	PingStub        func(logger lager.Logger) bool
	pingMutex       sync.RWMutex
	pingArgsForCall []struct {
		logger lager.Logger
	}
	pingReturns struct {
		result1 bool
	}
	pingReturnsOnCall map[int]struct {
		result1 bool
	}
	CellsStub        func(logger lager.Logger) ([]*models.CellPresence, error)
	cellsMutex       sync.RWMutex
	cellsArgsForCall []struct {
		logger lager.Logger
	}
	cellsReturns struct {
		result1 []*models.CellPresence
		result2 error
	}
	cellsReturnsOnCall map[int]struct {
		result1 []*models.CellPresence
		result2 error
	}
	ClaimActualLRPStub        func(logger lager.Logger, processGuid string, index int, instanceKey *models.ActualLRPInstanceKey) error
	claimActualLRPMutex       sync.RWMutex
	claimActualLRPArgsForCall []struct {
		logger      lager.Logger
		processGuid string
		index       int
		instanceKey *models.ActualLRPInstanceKey
	}
	claimActualLRPReturns struct {
		result1 error
	}
	claimActualLRPReturnsOnCall map[int]struct {
		result1 error
	}
	StartActualLRPStub        func(logger lager.Logger, key *models.ActualLRPKey, instanceKey *models.ActualLRPInstanceKey, netInfo *models.ActualLRPNetInfo) error
	startActualLRPMutex       sync.RWMutex
	startActualLRPArgsForCall []struct {
		logger      lager.Logger
		key         *models.ActualLRPKey
		instanceKey *models.ActualLRPInstanceKey
		netInfo     *models.ActualLRPNetInfo
	}
	startActualLRPReturns struct {
		result1 error
	}
	startActualLRPReturnsOnCall map[int]struct {
		result1 error
	}
	CrashActualLRPStub        func(logger lager.Logger, key *models.ActualLRPKey, instanceKey *models.ActualLRPInstanceKey, errorMessage string) error
	crashActualLRPMutex       sync.RWMutex
	crashActualLRPArgsForCall []struct {
		logger       lager.Logger
		key          *models.ActualLRPKey
		instanceKey  *models.ActualLRPInstanceKey
		errorMessage string
	}
	crashActualLRPReturns struct {
		result1 error
	}
	crashActualLRPReturnsOnCall map[int]struct {
		result1 error
	}
	FailActualLRPStub        func(logger lager.Logger, key *models.ActualLRPKey, errorMessage string) error
	failActualLRPMutex       sync.RWMutex
	failActualLRPArgsForCall []struct {
		logger       lager.Logger
		key          *models.ActualLRPKey
		errorMessage string
	}
	failActualLRPReturns struct {
		result1 error
	}
	failActualLRPReturnsOnCall map[int]struct {
		result1 error
	}
	RemoveActualLRPStub        func(logger lager.Logger, processGuid string, index int, instanceKey *models.ActualLRPInstanceKey) error
	removeActualLRPMutex       sync.RWMutex
	removeActualLRPArgsForCall []struct {
		logger      lager.Logger
		processGuid string
		index       int
		instanceKey *models.ActualLRPInstanceKey
	}
	removeActualLRPReturns struct {
		result1 error
	}
	removeActualLRPReturnsOnCall map[int]struct {
		result1 error
	}
	EvacuateClaimedActualLRPStub        func(lager.Logger, *models.ActualLRPKey, *models.ActualLRPInstanceKey) (bool, error)
	evacuateClaimedActualLRPMutex       sync.RWMutex
	evacuateClaimedActualLRPArgsForCall []struct {
		arg1 lager.Logger
		arg2 *models.ActualLRPKey
		arg3 *models.ActualLRPInstanceKey
	}
	evacuateClaimedActualLRPReturns struct {
		result1 bool
		result2 error
	}
	evacuateClaimedActualLRPReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	EvacuateRunningActualLRPStub        func(lager.Logger, *models.ActualLRPKey, *models.ActualLRPInstanceKey, *models.ActualLRPNetInfo, uint64) (bool, error)
	evacuateRunningActualLRPMutex       sync.RWMutex
	evacuateRunningActualLRPArgsForCall []struct {
		arg1 lager.Logger
		arg2 *models.ActualLRPKey
		arg3 *models.ActualLRPInstanceKey
		arg4 *models.ActualLRPNetInfo
		arg5 uint64
	}
	evacuateRunningActualLRPReturns struct {
		result1 bool
		result2 error
	}
	evacuateRunningActualLRPReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	EvacuateStoppedActualLRPStub        func(lager.Logger, *models.ActualLRPKey, *models.ActualLRPInstanceKey) (bool, error)
	evacuateStoppedActualLRPMutex       sync.RWMutex
	evacuateStoppedActualLRPArgsForCall []struct {
		arg1 lager.Logger
		arg2 *models.ActualLRPKey
		arg3 *models.ActualLRPInstanceKey
	}
	evacuateStoppedActualLRPReturns struct {
		result1 bool
		result2 error
	}
	evacuateStoppedActualLRPReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	EvacuateCrashedActualLRPStub        func(lager.Logger, *models.ActualLRPKey, *models.ActualLRPInstanceKey, string) (bool, error)
	evacuateCrashedActualLRPMutex       sync.RWMutex
	evacuateCrashedActualLRPArgsForCall []struct {
		arg1 lager.Logger
		arg2 *models.ActualLRPKey
		arg3 *models.ActualLRPInstanceKey
		arg4 string
	}
	evacuateCrashedActualLRPReturns struct {
		result1 bool
		result2 error
	}
	evacuateCrashedActualLRPReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	RemoveEvacuatingActualLRPStub        func(lager.Logger, *models.ActualLRPKey, *models.ActualLRPInstanceKey) error
	removeEvacuatingActualLRPMutex       sync.RWMutex
	removeEvacuatingActualLRPArgsForCall []struct {
		arg1 lager.Logger
		arg2 *models.ActualLRPKey
		arg3 *models.ActualLRPInstanceKey
	}
	removeEvacuatingActualLRPReturns struct {
		result1 error
	}
	removeEvacuatingActualLRPReturnsOnCall map[int]struct {
		result1 error
	}
	StartTaskStub        func(logger lager.Logger, taskGuid string, cellID string) (bool, error)
	startTaskMutex       sync.RWMutex
	startTaskArgsForCall []struct {
		logger   lager.Logger
		taskGuid string
		cellID   string
	}
	startTaskReturns struct {
		result1 bool
		result2 error
	}
	startTaskReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	FailTaskStub        func(logger lager.Logger, taskGuid, failureReason string) error
	failTaskMutex       sync.RWMutex
	failTaskArgsForCall []struct {
		logger        lager.Logger
		taskGuid      string
		failureReason string
	}
	failTaskReturns struct {
		result1 error
	}
	failTaskReturnsOnCall map[int]struct {
		result1 error
	}
	CompleteTaskStub        func(logger lager.Logger, taskGuid, cellId string, failed bool, failureReason, result string) error
	completeTaskMutex       sync.RWMutex
	completeTaskArgsForCall []struct {
		logger        lager.Logger
		taskGuid      string
		cellId        string
		failed        bool
		failureReason string
		result        string
	}
	completeTaskReturns struct {
		result1 error
	}
	completeTaskReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeInternalClient) DesireTask(logger lager.Logger, guid string, domain string, def *models.TaskDefinition) error {
	fake.desireTaskMutex.Lock()
	ret, specificReturn := fake.desireTaskReturnsOnCall[len(fake.desireTaskArgsForCall)]
	fake.desireTaskArgsForCall = append(fake.desireTaskArgsForCall, struct {
		logger lager.Logger
		guid   string
		domain string
		def    *models.TaskDefinition
	}{logger, guid, domain, def})
	fake.recordInvocation("DesireTask", []interface{}{logger, guid, domain, def})
	fake.desireTaskMutex.Unlock()
	if fake.DesireTaskStub != nil {
		return fake.DesireTaskStub(logger, guid, domain, def)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.desireTaskReturns.result1
}

func (fake *FakeInternalClient) DesireTaskCallCount() int {
	fake.desireTaskMutex.RLock()
	defer fake.desireTaskMutex.RUnlock()
	return len(fake.desireTaskArgsForCall)
}

func (fake *FakeInternalClient) DesireTaskArgsForCall(i int) (lager.Logger, string, string, *models.TaskDefinition) {
	fake.desireTaskMutex.RLock()
	defer fake.desireTaskMutex.RUnlock()
	return fake.desireTaskArgsForCall[i].logger, fake.desireTaskArgsForCall[i].guid, fake.desireTaskArgsForCall[i].domain, fake.desireTaskArgsForCall[i].def
}

func (fake *FakeInternalClient) DesireTaskReturns(result1 error) {
	fake.DesireTaskStub = nil
	fake.desireTaskReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeInternalClient) DesireTaskReturnsOnCall(i int, result1 error) {
	fake.DesireTaskStub = nil
	if fake.desireTaskReturnsOnCall == nil {
		fake.desireTaskReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.desireTaskReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeInternalClient) Tasks(logger lager.Logger) ([]*models.Task, error) {
	fake.tasksMutex.Lock()
	ret, specificReturn := fake.tasksReturnsOnCall[len(fake.tasksArgsForCall)]
	fake.tasksArgsForCall = append(fake.tasksArgsForCall, struct {
		logger lager.Logger
	}{logger})
	fake.recordInvocation("Tasks", []interface{}{logger})
	fake.tasksMutex.Unlock()
	if fake.TasksStub != nil {
		return fake.TasksStub(logger)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.tasksReturns.result1, fake.tasksReturns.result2
}

func (fake *FakeInternalClient) TasksCallCount() int {
	fake.tasksMutex.RLock()
	defer fake.tasksMutex.RUnlock()
	return len(fake.tasksArgsForCall)
}

func (fake *FakeInternalClient) TasksArgsForCall(i int) lager.Logger {
	fake.tasksMutex.RLock()
	defer fake.tasksMutex.RUnlock()
	return fake.tasksArgsForCall[i].logger
}

func (fake *FakeInternalClient) TasksReturns(result1 []*models.Task, result2 error) {
	fake.TasksStub = nil
	fake.tasksReturns = struct {
		result1 []*models.Task
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) TasksReturnsOnCall(i int, result1 []*models.Task, result2 error) {
	fake.TasksStub = nil
	if fake.tasksReturnsOnCall == nil {
		fake.tasksReturnsOnCall = make(map[int]struct {
			result1 []*models.Task
			result2 error
		})
	}
	fake.tasksReturnsOnCall[i] = struct {
		result1 []*models.Task
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) TasksWithFilter(logger lager.Logger, filter models.TaskFilter) ([]*models.Task, error) {
	fake.tasksWithFilterMutex.Lock()
	ret, specificReturn := fake.tasksWithFilterReturnsOnCall[len(fake.tasksWithFilterArgsForCall)]
	fake.tasksWithFilterArgsForCall = append(fake.tasksWithFilterArgsForCall, struct {
		logger lager.Logger
		filter models.TaskFilter
	}{logger, filter})
	fake.recordInvocation("TasksWithFilter", []interface{}{logger, filter})
	fake.tasksWithFilterMutex.Unlock()
	if fake.TasksWithFilterStub != nil {
		return fake.TasksWithFilterStub(logger, filter)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.tasksWithFilterReturns.result1, fake.tasksWithFilterReturns.result2
}

func (fake *FakeInternalClient) TasksWithFilterCallCount() int {
	fake.tasksWithFilterMutex.RLock()
	defer fake.tasksWithFilterMutex.RUnlock()
	return len(fake.tasksWithFilterArgsForCall)
}

func (fake *FakeInternalClient) TasksWithFilterArgsForCall(i int) (lager.Logger, models.TaskFilter) {
	fake.tasksWithFilterMutex.RLock()
	defer fake.tasksWithFilterMutex.RUnlock()
	return fake.tasksWithFilterArgsForCall[i].logger, fake.tasksWithFilterArgsForCall[i].filter
}

func (fake *FakeInternalClient) TasksWithFilterReturns(result1 []*models.Task, result2 error) {
	fake.TasksWithFilterStub = nil
	fake.tasksWithFilterReturns = struct {
		result1 []*models.Task
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) TasksWithFilterReturnsOnCall(i int, result1 []*models.Task, result2 error) {
	fake.TasksWithFilterStub = nil
	if fake.tasksWithFilterReturnsOnCall == nil {
		fake.tasksWithFilterReturnsOnCall = make(map[int]struct {
			result1 []*models.Task
			result2 error
		})
	}
	fake.tasksWithFilterReturnsOnCall[i] = struct {
		result1 []*models.Task
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) TasksByDomain(logger lager.Logger, domain string) ([]*models.Task, error) {
	fake.tasksByDomainMutex.Lock()
	ret, specificReturn := fake.tasksByDomainReturnsOnCall[len(fake.tasksByDomainArgsForCall)]
	fake.tasksByDomainArgsForCall = append(fake.tasksByDomainArgsForCall, struct {
		logger lager.Logger
		domain string
	}{logger, domain})
	fake.recordInvocation("TasksByDomain", []interface{}{logger, domain})
	fake.tasksByDomainMutex.Unlock()
	if fake.TasksByDomainStub != nil {
		return fake.TasksByDomainStub(logger, domain)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.tasksByDomainReturns.result1, fake.tasksByDomainReturns.result2
}

func (fake *FakeInternalClient) TasksByDomainCallCount() int {
	fake.tasksByDomainMutex.RLock()
	defer fake.tasksByDomainMutex.RUnlock()
	return len(fake.tasksByDomainArgsForCall)
}

func (fake *FakeInternalClient) TasksByDomainArgsForCall(i int) (lager.Logger, string) {
	fake.tasksByDomainMutex.RLock()
	defer fake.tasksByDomainMutex.RUnlock()
	return fake.tasksByDomainArgsForCall[i].logger, fake.tasksByDomainArgsForCall[i].domain
}

func (fake *FakeInternalClient) TasksByDomainReturns(result1 []*models.Task, result2 error) {
	fake.TasksByDomainStub = nil
	fake.tasksByDomainReturns = struct {
		result1 []*models.Task
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) TasksByDomainReturnsOnCall(i int, result1 []*models.Task, result2 error) {
	fake.TasksByDomainStub = nil
	if fake.tasksByDomainReturnsOnCall == nil {
		fake.tasksByDomainReturnsOnCall = make(map[int]struct {
			result1 []*models.Task
			result2 error
		})
	}
	fake.tasksByDomainReturnsOnCall[i] = struct {
		result1 []*models.Task
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) TasksByCellID(logger lager.Logger, cellId string) ([]*models.Task, error) {
	fake.tasksByCellIDMutex.Lock()
	ret, specificReturn := fake.tasksByCellIDReturnsOnCall[len(fake.tasksByCellIDArgsForCall)]
	fake.tasksByCellIDArgsForCall = append(fake.tasksByCellIDArgsForCall, struct {
		logger lager.Logger
		cellId string
	}{logger, cellId})
	fake.recordInvocation("TasksByCellID", []interface{}{logger, cellId})
	fake.tasksByCellIDMutex.Unlock()
	if fake.TasksByCellIDStub != nil {
		return fake.TasksByCellIDStub(logger, cellId)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.tasksByCellIDReturns.result1, fake.tasksByCellIDReturns.result2
}

func (fake *FakeInternalClient) TasksByCellIDCallCount() int {
	fake.tasksByCellIDMutex.RLock()
	defer fake.tasksByCellIDMutex.RUnlock()
	return len(fake.tasksByCellIDArgsForCall)
}

func (fake *FakeInternalClient) TasksByCellIDArgsForCall(i int) (lager.Logger, string) {
	fake.tasksByCellIDMutex.RLock()
	defer fake.tasksByCellIDMutex.RUnlock()
	return fake.tasksByCellIDArgsForCall[i].logger, fake.tasksByCellIDArgsForCall[i].cellId
}

func (fake *FakeInternalClient) TasksByCellIDReturns(result1 []*models.Task, result2 error) {
	fake.TasksByCellIDStub = nil
	fake.tasksByCellIDReturns = struct {
		result1 []*models.Task
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) TasksByCellIDReturnsOnCall(i int, result1 []*models.Task, result2 error) {
	fake.TasksByCellIDStub = nil
	if fake.tasksByCellIDReturnsOnCall == nil {
		fake.tasksByCellIDReturnsOnCall = make(map[int]struct {
			result1 []*models.Task
			result2 error
		})
	}
	fake.tasksByCellIDReturnsOnCall[i] = struct {
		result1 []*models.Task
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) TaskByGuid(logger lager.Logger, guid string) (*models.Task, error) {
	fake.taskByGuidMutex.Lock()
	ret, specificReturn := fake.taskByGuidReturnsOnCall[len(fake.taskByGuidArgsForCall)]
	fake.taskByGuidArgsForCall = append(fake.taskByGuidArgsForCall, struct {
		logger lager.Logger
		guid   string
	}{logger, guid})
	fake.recordInvocation("TaskByGuid", []interface{}{logger, guid})
	fake.taskByGuidMutex.Unlock()
	if fake.TaskByGuidStub != nil {
		return fake.TaskByGuidStub(logger, guid)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.taskByGuidReturns.result1, fake.taskByGuidReturns.result2
}

func (fake *FakeInternalClient) TaskByGuidCallCount() int {
	fake.taskByGuidMutex.RLock()
	defer fake.taskByGuidMutex.RUnlock()
	return len(fake.taskByGuidArgsForCall)
}

func (fake *FakeInternalClient) TaskByGuidArgsForCall(i int) (lager.Logger, string) {
	fake.taskByGuidMutex.RLock()
	defer fake.taskByGuidMutex.RUnlock()
	return fake.taskByGuidArgsForCall[i].logger, fake.taskByGuidArgsForCall[i].guid
}

func (fake *FakeInternalClient) TaskByGuidReturns(result1 *models.Task, result2 error) {
	fake.TaskByGuidStub = nil
	fake.taskByGuidReturns = struct {
		result1 *models.Task
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) TaskByGuidReturnsOnCall(i int, result1 *models.Task, result2 error) {
	fake.TaskByGuidStub = nil
	if fake.taskByGuidReturnsOnCall == nil {
		fake.taskByGuidReturnsOnCall = make(map[int]struct {
			result1 *models.Task
			result2 error
		})
	}
	fake.taskByGuidReturnsOnCall[i] = struct {
		result1 *models.Task
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) CancelTask(logger lager.Logger, taskGuid string) error {
	fake.cancelTaskMutex.Lock()
	ret, specificReturn := fake.cancelTaskReturnsOnCall[len(fake.cancelTaskArgsForCall)]
	fake.cancelTaskArgsForCall = append(fake.cancelTaskArgsForCall, struct {
		logger   lager.Logger
		taskGuid string
	}{logger, taskGuid})
	fake.recordInvocation("CancelTask", []interface{}{logger, taskGuid})
	fake.cancelTaskMutex.Unlock()
	if fake.CancelTaskStub != nil {
		return fake.CancelTaskStub(logger, taskGuid)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.cancelTaskReturns.result1
}

func (fake *FakeInternalClient) CancelTaskCallCount() int {
	fake.cancelTaskMutex.RLock()
	defer fake.cancelTaskMutex.RUnlock()
	return len(fake.cancelTaskArgsForCall)
}

func (fake *FakeInternalClient) CancelTaskArgsForCall(i int) (lager.Logger, string) {
	fake.cancelTaskMutex.RLock()
	defer fake.cancelTaskMutex.RUnlock()
	return fake.cancelTaskArgsForCall[i].logger, fake.cancelTaskArgsForCall[i].taskGuid
}

func (fake *FakeInternalClient) CancelTaskReturns(result1 error) {
	fake.CancelTaskStub = nil
	fake.cancelTaskReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeInternalClient) CancelTaskReturnsOnCall(i int, result1 error) {
	fake.CancelTaskStub = nil
	if fake.cancelTaskReturnsOnCall == nil {
		fake.cancelTaskReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.cancelTaskReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeInternalClient) ResolvingTask(logger lager.Logger, taskGuid string) error {
	fake.resolvingTaskMutex.Lock()
	ret, specificReturn := fake.resolvingTaskReturnsOnCall[len(fake.resolvingTaskArgsForCall)]
	fake.resolvingTaskArgsForCall = append(fake.resolvingTaskArgsForCall, struct {
		logger   lager.Logger
		taskGuid string
	}{logger, taskGuid})
	fake.recordInvocation("ResolvingTask", []interface{}{logger, taskGuid})
	fake.resolvingTaskMutex.Unlock()
	if fake.ResolvingTaskStub != nil {
		return fake.ResolvingTaskStub(logger, taskGuid)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.resolvingTaskReturns.result1
}

func (fake *FakeInternalClient) ResolvingTaskCallCount() int {
	fake.resolvingTaskMutex.RLock()
	defer fake.resolvingTaskMutex.RUnlock()
	return len(fake.resolvingTaskArgsForCall)
}

func (fake *FakeInternalClient) ResolvingTaskArgsForCall(i int) (lager.Logger, string) {
	fake.resolvingTaskMutex.RLock()
	defer fake.resolvingTaskMutex.RUnlock()
	return fake.resolvingTaskArgsForCall[i].logger, fake.resolvingTaskArgsForCall[i].taskGuid
}

func (fake *FakeInternalClient) ResolvingTaskReturns(result1 error) {
	fake.ResolvingTaskStub = nil
	fake.resolvingTaskReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeInternalClient) ResolvingTaskReturnsOnCall(i int, result1 error) {
	fake.ResolvingTaskStub = nil
	if fake.resolvingTaskReturnsOnCall == nil {
		fake.resolvingTaskReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.resolvingTaskReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeInternalClient) DeleteTask(logger lager.Logger, taskGuid string) error {
	fake.deleteTaskMutex.Lock()
	ret, specificReturn := fake.deleteTaskReturnsOnCall[len(fake.deleteTaskArgsForCall)]
	fake.deleteTaskArgsForCall = append(fake.deleteTaskArgsForCall, struct {
		logger   lager.Logger
		taskGuid string
	}{logger, taskGuid})
	fake.recordInvocation("DeleteTask", []interface{}{logger, taskGuid})
	fake.deleteTaskMutex.Unlock()
	if fake.DeleteTaskStub != nil {
		return fake.DeleteTaskStub(logger, taskGuid)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.deleteTaskReturns.result1
}

func (fake *FakeInternalClient) DeleteTaskCallCount() int {
	fake.deleteTaskMutex.RLock()
	defer fake.deleteTaskMutex.RUnlock()
	return len(fake.deleteTaskArgsForCall)
}

func (fake *FakeInternalClient) DeleteTaskArgsForCall(i int) (lager.Logger, string) {
	fake.deleteTaskMutex.RLock()
	defer fake.deleteTaskMutex.RUnlock()
	return fake.deleteTaskArgsForCall[i].logger, fake.deleteTaskArgsForCall[i].taskGuid
}

func (fake *FakeInternalClient) DeleteTaskReturns(result1 error) {
	fake.DeleteTaskStub = nil
	fake.deleteTaskReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeInternalClient) DeleteTaskReturnsOnCall(i int, result1 error) {
	fake.DeleteTaskStub = nil
	if fake.deleteTaskReturnsOnCall == nil {
		fake.deleteTaskReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteTaskReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeInternalClient) Domains(logger lager.Logger) ([]string, error) {
	fake.domainsMutex.Lock()
	ret, specificReturn := fake.domainsReturnsOnCall[len(fake.domainsArgsForCall)]
	fake.domainsArgsForCall = append(fake.domainsArgsForCall, struct {
		logger lager.Logger
	}{logger})
	fake.recordInvocation("Domains", []interface{}{logger})
	fake.domainsMutex.Unlock()
	if fake.DomainsStub != nil {
		return fake.DomainsStub(logger)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.domainsReturns.result1, fake.domainsReturns.result2
}

func (fake *FakeInternalClient) DomainsCallCount() int {
	fake.domainsMutex.RLock()
	defer fake.domainsMutex.RUnlock()
	return len(fake.domainsArgsForCall)
}

func (fake *FakeInternalClient) DomainsArgsForCall(i int) lager.Logger {
	fake.domainsMutex.RLock()
	defer fake.domainsMutex.RUnlock()
	return fake.domainsArgsForCall[i].logger
}

func (fake *FakeInternalClient) DomainsReturns(result1 []string, result2 error) {
	fake.DomainsStub = nil
	fake.domainsReturns = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) DomainsReturnsOnCall(i int, result1 []string, result2 error) {
	fake.DomainsStub = nil
	if fake.domainsReturnsOnCall == nil {
		fake.domainsReturnsOnCall = make(map[int]struct {
			result1 []string
			result2 error
		})
	}
	fake.domainsReturnsOnCall[i] = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) UpsertDomain(logger lager.Logger, domain string, ttl time.Duration) error {
	fake.upsertDomainMutex.Lock()
	ret, specificReturn := fake.upsertDomainReturnsOnCall[len(fake.upsertDomainArgsForCall)]
	fake.upsertDomainArgsForCall = append(fake.upsertDomainArgsForCall, struct {
		logger lager.Logger
		domain string
		ttl    time.Duration
	}{logger, domain, ttl})
	fake.recordInvocation("UpsertDomain", []interface{}{logger, domain, ttl})
	fake.upsertDomainMutex.Unlock()
	if fake.UpsertDomainStub != nil {
		return fake.UpsertDomainStub(logger, domain, ttl)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.upsertDomainReturns.result1
}

func (fake *FakeInternalClient) UpsertDomainCallCount() int {
	fake.upsertDomainMutex.RLock()
	defer fake.upsertDomainMutex.RUnlock()
	return len(fake.upsertDomainArgsForCall)
}

func (fake *FakeInternalClient) UpsertDomainArgsForCall(i int) (lager.Logger, string, time.Duration) {
	fake.upsertDomainMutex.RLock()
	defer fake.upsertDomainMutex.RUnlock()
	return fake.upsertDomainArgsForCall[i].logger, fake.upsertDomainArgsForCall[i].domain, fake.upsertDomainArgsForCall[i].ttl
}

func (fake *FakeInternalClient) UpsertDomainReturns(result1 error) {
	fake.UpsertDomainStub = nil
	fake.upsertDomainReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeInternalClient) UpsertDomainReturnsOnCall(i int, result1 error) {
	fake.UpsertDomainStub = nil
	if fake.upsertDomainReturnsOnCall == nil {
		fake.upsertDomainReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.upsertDomainReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeInternalClient) ActualLRPGroups(arg1 lager.Logger, arg2 models.ActualLRPFilter) ([]*models.ActualLRPGroup, error) {
	fake.actualLRPGroupsMutex.Lock()
	ret, specificReturn := fake.actualLRPGroupsReturnsOnCall[len(fake.actualLRPGroupsArgsForCall)]
	fake.actualLRPGroupsArgsForCall = append(fake.actualLRPGroupsArgsForCall, struct {
		arg1 lager.Logger
		arg2 models.ActualLRPFilter
	}{arg1, arg2})
	fake.recordInvocation("ActualLRPGroups", []interface{}{arg1, arg2})
	fake.actualLRPGroupsMutex.Unlock()
	if fake.ActualLRPGroupsStub != nil {
		return fake.ActualLRPGroupsStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.actualLRPGroupsReturns.result1, fake.actualLRPGroupsReturns.result2
}

func (fake *FakeInternalClient) ActualLRPGroupsCallCount() int {
	fake.actualLRPGroupsMutex.RLock()
	defer fake.actualLRPGroupsMutex.RUnlock()
	return len(fake.actualLRPGroupsArgsForCall)
}

func (fake *FakeInternalClient) ActualLRPGroupsArgsForCall(i int) (lager.Logger, models.ActualLRPFilter) {
	fake.actualLRPGroupsMutex.RLock()
	defer fake.actualLRPGroupsMutex.RUnlock()
	return fake.actualLRPGroupsArgsForCall[i].arg1, fake.actualLRPGroupsArgsForCall[i].arg2
}

func (fake *FakeInternalClient) ActualLRPGroupsReturns(result1 []*models.ActualLRPGroup, result2 error) {
	fake.ActualLRPGroupsStub = nil
	fake.actualLRPGroupsReturns = struct {
		result1 []*models.ActualLRPGroup
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) ActualLRPGroupsReturnsOnCall(i int, result1 []*models.ActualLRPGroup, result2 error) {
	fake.ActualLRPGroupsStub = nil
	if fake.actualLRPGroupsReturnsOnCall == nil {
		fake.actualLRPGroupsReturnsOnCall = make(map[int]struct {
			result1 []*models.ActualLRPGroup
			result2 error
		})
	}
	fake.actualLRPGroupsReturnsOnCall[i] = struct {
		result1 []*models.ActualLRPGroup
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) ActualLRPGroupsByProcessGuid(logger lager.Logger, processGuid string) ([]*models.ActualLRPGroup, error) {
	fake.actualLRPGroupsByProcessGuidMutex.Lock()
	ret, specificReturn := fake.actualLRPGroupsByProcessGuidReturnsOnCall[len(fake.actualLRPGroupsByProcessGuidArgsForCall)]
	fake.actualLRPGroupsByProcessGuidArgsForCall = append(fake.actualLRPGroupsByProcessGuidArgsForCall, struct {
		logger      lager.Logger
		processGuid string
	}{logger, processGuid})
	fake.recordInvocation("ActualLRPGroupsByProcessGuid", []interface{}{logger, processGuid})
	fake.actualLRPGroupsByProcessGuidMutex.Unlock()
	if fake.ActualLRPGroupsByProcessGuidStub != nil {
		return fake.ActualLRPGroupsByProcessGuidStub(logger, processGuid)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.actualLRPGroupsByProcessGuidReturns.result1, fake.actualLRPGroupsByProcessGuidReturns.result2
}

func (fake *FakeInternalClient) ActualLRPGroupsByProcessGuidCallCount() int {
	fake.actualLRPGroupsByProcessGuidMutex.RLock()
	defer fake.actualLRPGroupsByProcessGuidMutex.RUnlock()
	return len(fake.actualLRPGroupsByProcessGuidArgsForCall)
}

func (fake *FakeInternalClient) ActualLRPGroupsByProcessGuidArgsForCall(i int) (lager.Logger, string) {
	fake.actualLRPGroupsByProcessGuidMutex.RLock()
	defer fake.actualLRPGroupsByProcessGuidMutex.RUnlock()
	return fake.actualLRPGroupsByProcessGuidArgsForCall[i].logger, fake.actualLRPGroupsByProcessGuidArgsForCall[i].processGuid
}

func (fake *FakeInternalClient) ActualLRPGroupsByProcessGuidReturns(result1 []*models.ActualLRPGroup, result2 error) {
	fake.ActualLRPGroupsByProcessGuidStub = nil
	fake.actualLRPGroupsByProcessGuidReturns = struct {
		result1 []*models.ActualLRPGroup
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) ActualLRPGroupsByProcessGuidReturnsOnCall(i int, result1 []*models.ActualLRPGroup, result2 error) {
	fake.ActualLRPGroupsByProcessGuidStub = nil
	if fake.actualLRPGroupsByProcessGuidReturnsOnCall == nil {
		fake.actualLRPGroupsByProcessGuidReturnsOnCall = make(map[int]struct {
			result1 []*models.ActualLRPGroup
			result2 error
		})
	}
	fake.actualLRPGroupsByProcessGuidReturnsOnCall[i] = struct {
		result1 []*models.ActualLRPGroup
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) ActualLRPGroupByProcessGuidAndIndex(logger lager.Logger, processGuid string, index int) (*models.ActualLRPGroup, error) {
	fake.actualLRPGroupByProcessGuidAndIndexMutex.Lock()
	ret, specificReturn := fake.actualLRPGroupByProcessGuidAndIndexReturnsOnCall[len(fake.actualLRPGroupByProcessGuidAndIndexArgsForCall)]
	fake.actualLRPGroupByProcessGuidAndIndexArgsForCall = append(fake.actualLRPGroupByProcessGuidAndIndexArgsForCall, struct {
		logger      lager.Logger
		processGuid string
		index       int
	}{logger, processGuid, index})
	fake.recordInvocation("ActualLRPGroupByProcessGuidAndIndex", []interface{}{logger, processGuid, index})
	fake.actualLRPGroupByProcessGuidAndIndexMutex.Unlock()
	if fake.ActualLRPGroupByProcessGuidAndIndexStub != nil {
		return fake.ActualLRPGroupByProcessGuidAndIndexStub(logger, processGuid, index)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.actualLRPGroupByProcessGuidAndIndexReturns.result1, fake.actualLRPGroupByProcessGuidAndIndexReturns.result2
}

func (fake *FakeInternalClient) ActualLRPGroupByProcessGuidAndIndexCallCount() int {
	fake.actualLRPGroupByProcessGuidAndIndexMutex.RLock()
	defer fake.actualLRPGroupByProcessGuidAndIndexMutex.RUnlock()
	return len(fake.actualLRPGroupByProcessGuidAndIndexArgsForCall)
}

func (fake *FakeInternalClient) ActualLRPGroupByProcessGuidAndIndexArgsForCall(i int) (lager.Logger, string, int) {
	fake.actualLRPGroupByProcessGuidAndIndexMutex.RLock()
	defer fake.actualLRPGroupByProcessGuidAndIndexMutex.RUnlock()
	return fake.actualLRPGroupByProcessGuidAndIndexArgsForCall[i].logger, fake.actualLRPGroupByProcessGuidAndIndexArgsForCall[i].processGuid, fake.actualLRPGroupByProcessGuidAndIndexArgsForCall[i].index
}

func (fake *FakeInternalClient) ActualLRPGroupByProcessGuidAndIndexReturns(result1 *models.ActualLRPGroup, result2 error) {
	fake.ActualLRPGroupByProcessGuidAndIndexStub = nil
	fake.actualLRPGroupByProcessGuidAndIndexReturns = struct {
		result1 *models.ActualLRPGroup
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) ActualLRPGroupByProcessGuidAndIndexReturnsOnCall(i int, result1 *models.ActualLRPGroup, result2 error) {
	fake.ActualLRPGroupByProcessGuidAndIndexStub = nil
	if fake.actualLRPGroupByProcessGuidAndIndexReturnsOnCall == nil {
		fake.actualLRPGroupByProcessGuidAndIndexReturnsOnCall = make(map[int]struct {
			result1 *models.ActualLRPGroup
			result2 error
		})
	}
	fake.actualLRPGroupByProcessGuidAndIndexReturnsOnCall[i] = struct {
		result1 *models.ActualLRPGroup
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) RetireActualLRP(logger lager.Logger, key *models.ActualLRPKey) error {
	fake.retireActualLRPMutex.Lock()
	ret, specificReturn := fake.retireActualLRPReturnsOnCall[len(fake.retireActualLRPArgsForCall)]
	fake.retireActualLRPArgsForCall = append(fake.retireActualLRPArgsForCall, struct {
		logger lager.Logger
		key    *models.ActualLRPKey
	}{logger, key})
	fake.recordInvocation("RetireActualLRP", []interface{}{logger, key})
	fake.retireActualLRPMutex.Unlock()
	if fake.RetireActualLRPStub != nil {
		return fake.RetireActualLRPStub(logger, key)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.retireActualLRPReturns.result1
}

func (fake *FakeInternalClient) RetireActualLRPCallCount() int {
	fake.retireActualLRPMutex.RLock()
	defer fake.retireActualLRPMutex.RUnlock()
	return len(fake.retireActualLRPArgsForCall)
}

func (fake *FakeInternalClient) RetireActualLRPArgsForCall(i int) (lager.Logger, *models.ActualLRPKey) {
	fake.retireActualLRPMutex.RLock()
	defer fake.retireActualLRPMutex.RUnlock()
	return fake.retireActualLRPArgsForCall[i].logger, fake.retireActualLRPArgsForCall[i].key
}

func (fake *FakeInternalClient) RetireActualLRPReturns(result1 error) {
	fake.RetireActualLRPStub = nil
	fake.retireActualLRPReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeInternalClient) RetireActualLRPReturnsOnCall(i int, result1 error) {
	fake.RetireActualLRPStub = nil
	if fake.retireActualLRPReturnsOnCall == nil {
		fake.retireActualLRPReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.retireActualLRPReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeInternalClient) DesiredLRPs(arg1 lager.Logger, arg2 models.DesiredLRPFilter) ([]*models.DesiredLRP, error) {
	fake.desiredLRPsMutex.Lock()
	ret, specificReturn := fake.desiredLRPsReturnsOnCall[len(fake.desiredLRPsArgsForCall)]
	fake.desiredLRPsArgsForCall = append(fake.desiredLRPsArgsForCall, struct {
		arg1 lager.Logger
		arg2 models.DesiredLRPFilter
	}{arg1, arg2})
	fake.recordInvocation("DesiredLRPs", []interface{}{arg1, arg2})
	fake.desiredLRPsMutex.Unlock()
	if fake.DesiredLRPsStub != nil {
		return fake.DesiredLRPsStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.desiredLRPsReturns.result1, fake.desiredLRPsReturns.result2
}

func (fake *FakeInternalClient) DesiredLRPsCallCount() int {
	fake.desiredLRPsMutex.RLock()
	defer fake.desiredLRPsMutex.RUnlock()
	return len(fake.desiredLRPsArgsForCall)
}

func (fake *FakeInternalClient) DesiredLRPsArgsForCall(i int) (lager.Logger, models.DesiredLRPFilter) {
	fake.desiredLRPsMutex.RLock()
	defer fake.desiredLRPsMutex.RUnlock()
	return fake.desiredLRPsArgsForCall[i].arg1, fake.desiredLRPsArgsForCall[i].arg2
}

func (fake *FakeInternalClient) DesiredLRPsReturns(result1 []*models.DesiredLRP, result2 error) {
	fake.DesiredLRPsStub = nil
	fake.desiredLRPsReturns = struct {
		result1 []*models.DesiredLRP
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) DesiredLRPsReturnsOnCall(i int, result1 []*models.DesiredLRP, result2 error) {
	fake.DesiredLRPsStub = nil
	if fake.desiredLRPsReturnsOnCall == nil {
		fake.desiredLRPsReturnsOnCall = make(map[int]struct {
			result1 []*models.DesiredLRP
			result2 error
		})
	}
	fake.desiredLRPsReturnsOnCall[i] = struct {
		result1 []*models.DesiredLRP
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) DesiredLRPByProcessGuid(logger lager.Logger, processGuid string) (*models.DesiredLRP, error) {
	fake.desiredLRPByProcessGuidMutex.Lock()
	ret, specificReturn := fake.desiredLRPByProcessGuidReturnsOnCall[len(fake.desiredLRPByProcessGuidArgsForCall)]
	fake.desiredLRPByProcessGuidArgsForCall = append(fake.desiredLRPByProcessGuidArgsForCall, struct {
		logger      lager.Logger
		processGuid string
	}{logger, processGuid})
	fake.recordInvocation("DesiredLRPByProcessGuid", []interface{}{logger, processGuid})
	fake.desiredLRPByProcessGuidMutex.Unlock()
	if fake.DesiredLRPByProcessGuidStub != nil {
		return fake.DesiredLRPByProcessGuidStub(logger, processGuid)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.desiredLRPByProcessGuidReturns.result1, fake.desiredLRPByProcessGuidReturns.result2
}

func (fake *FakeInternalClient) DesiredLRPByProcessGuidCallCount() int {
	fake.desiredLRPByProcessGuidMutex.RLock()
	defer fake.desiredLRPByProcessGuidMutex.RUnlock()
	return len(fake.desiredLRPByProcessGuidArgsForCall)
}

func (fake *FakeInternalClient) DesiredLRPByProcessGuidArgsForCall(i int) (lager.Logger, string) {
	fake.desiredLRPByProcessGuidMutex.RLock()
	defer fake.desiredLRPByProcessGuidMutex.RUnlock()
	return fake.desiredLRPByProcessGuidArgsForCall[i].logger, fake.desiredLRPByProcessGuidArgsForCall[i].processGuid
}

func (fake *FakeInternalClient) DesiredLRPByProcessGuidReturns(result1 *models.DesiredLRP, result2 error) {
	fake.DesiredLRPByProcessGuidStub = nil
	fake.desiredLRPByProcessGuidReturns = struct {
		result1 *models.DesiredLRP
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) DesiredLRPByProcessGuidReturnsOnCall(i int, result1 *models.DesiredLRP, result2 error) {
	fake.DesiredLRPByProcessGuidStub = nil
	if fake.desiredLRPByProcessGuidReturnsOnCall == nil {
		fake.desiredLRPByProcessGuidReturnsOnCall = make(map[int]struct {
			result1 *models.DesiredLRP
			result2 error
		})
	}
	fake.desiredLRPByProcessGuidReturnsOnCall[i] = struct {
		result1 *models.DesiredLRP
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) DesiredLRPSchedulingInfos(arg1 lager.Logger, arg2 models.DesiredLRPFilter) ([]*models.DesiredLRPSchedulingInfo, error) {
	fake.desiredLRPSchedulingInfosMutex.Lock()
	ret, specificReturn := fake.desiredLRPSchedulingInfosReturnsOnCall[len(fake.desiredLRPSchedulingInfosArgsForCall)]
	fake.desiredLRPSchedulingInfosArgsForCall = append(fake.desiredLRPSchedulingInfosArgsForCall, struct {
		arg1 lager.Logger
		arg2 models.DesiredLRPFilter
	}{arg1, arg2})
	fake.recordInvocation("DesiredLRPSchedulingInfos", []interface{}{arg1, arg2})
	fake.desiredLRPSchedulingInfosMutex.Unlock()
	if fake.DesiredLRPSchedulingInfosStub != nil {
		return fake.DesiredLRPSchedulingInfosStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.desiredLRPSchedulingInfosReturns.result1, fake.desiredLRPSchedulingInfosReturns.result2
}

func (fake *FakeInternalClient) DesiredLRPSchedulingInfosCallCount() int {
	fake.desiredLRPSchedulingInfosMutex.RLock()
	defer fake.desiredLRPSchedulingInfosMutex.RUnlock()
	return len(fake.desiredLRPSchedulingInfosArgsForCall)
}

func (fake *FakeInternalClient) DesiredLRPSchedulingInfosArgsForCall(i int) (lager.Logger, models.DesiredLRPFilter) {
	fake.desiredLRPSchedulingInfosMutex.RLock()
	defer fake.desiredLRPSchedulingInfosMutex.RUnlock()
	return fake.desiredLRPSchedulingInfosArgsForCall[i].arg1, fake.desiredLRPSchedulingInfosArgsForCall[i].arg2
}

func (fake *FakeInternalClient) DesiredLRPSchedulingInfosReturns(result1 []*models.DesiredLRPSchedulingInfo, result2 error) {
	fake.DesiredLRPSchedulingInfosStub = nil
	fake.desiredLRPSchedulingInfosReturns = struct {
		result1 []*models.DesiredLRPSchedulingInfo
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) DesiredLRPSchedulingInfosReturnsOnCall(i int, result1 []*models.DesiredLRPSchedulingInfo, result2 error) {
	fake.DesiredLRPSchedulingInfosStub = nil
	if fake.desiredLRPSchedulingInfosReturnsOnCall == nil {
		fake.desiredLRPSchedulingInfosReturnsOnCall = make(map[int]struct {
			result1 []*models.DesiredLRPSchedulingInfo
			result2 error
		})
	}
	fake.desiredLRPSchedulingInfosReturnsOnCall[i] = struct {
		result1 []*models.DesiredLRPSchedulingInfo
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) DesireLRP(arg1 lager.Logger, arg2 *models.DesiredLRP) error {
	fake.desireLRPMutex.Lock()
	ret, specificReturn := fake.desireLRPReturnsOnCall[len(fake.desireLRPArgsForCall)]
	fake.desireLRPArgsForCall = append(fake.desireLRPArgsForCall, struct {
		arg1 lager.Logger
		arg2 *models.DesiredLRP
	}{arg1, arg2})
	fake.recordInvocation("DesireLRP", []interface{}{arg1, arg2})
	fake.desireLRPMutex.Unlock()
	if fake.DesireLRPStub != nil {
		return fake.DesireLRPStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.desireLRPReturns.result1
}

func (fake *FakeInternalClient) DesireLRPCallCount() int {
	fake.desireLRPMutex.RLock()
	defer fake.desireLRPMutex.RUnlock()
	return len(fake.desireLRPArgsForCall)
}

func (fake *FakeInternalClient) DesireLRPArgsForCall(i int) (lager.Logger, *models.DesiredLRP) {
	fake.desireLRPMutex.RLock()
	defer fake.desireLRPMutex.RUnlock()
	return fake.desireLRPArgsForCall[i].arg1, fake.desireLRPArgsForCall[i].arg2
}

func (fake *FakeInternalClient) DesireLRPReturns(result1 error) {
	fake.DesireLRPStub = nil
	fake.desireLRPReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeInternalClient) DesireLRPReturnsOnCall(i int, result1 error) {
	fake.DesireLRPStub = nil
	if fake.desireLRPReturnsOnCall == nil {
		fake.desireLRPReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.desireLRPReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeInternalClient) UpdateDesiredLRP(logger lager.Logger, processGuid string, update *models.DesiredLRPUpdate) error {
	fake.updateDesiredLRPMutex.Lock()
	ret, specificReturn := fake.updateDesiredLRPReturnsOnCall[len(fake.updateDesiredLRPArgsForCall)]
	fake.updateDesiredLRPArgsForCall = append(fake.updateDesiredLRPArgsForCall, struct {
		logger      lager.Logger
		processGuid string
		update      *models.DesiredLRPUpdate
	}{logger, processGuid, update})
	fake.recordInvocation("UpdateDesiredLRP", []interface{}{logger, processGuid, update})
	fake.updateDesiredLRPMutex.Unlock()
	if fake.UpdateDesiredLRPStub != nil {
		return fake.UpdateDesiredLRPStub(logger, processGuid, update)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.updateDesiredLRPReturns.result1
}

func (fake *FakeInternalClient) UpdateDesiredLRPCallCount() int {
	fake.updateDesiredLRPMutex.RLock()
	defer fake.updateDesiredLRPMutex.RUnlock()
	return len(fake.updateDesiredLRPArgsForCall)
}

func (fake *FakeInternalClient) UpdateDesiredLRPArgsForCall(i int) (lager.Logger, string, *models.DesiredLRPUpdate) {
	fake.updateDesiredLRPMutex.RLock()
	defer fake.updateDesiredLRPMutex.RUnlock()
	return fake.updateDesiredLRPArgsForCall[i].logger, fake.updateDesiredLRPArgsForCall[i].processGuid, fake.updateDesiredLRPArgsForCall[i].update
}

func (fake *FakeInternalClient) UpdateDesiredLRPReturns(result1 error) {
	fake.UpdateDesiredLRPStub = nil
	fake.updateDesiredLRPReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeInternalClient) UpdateDesiredLRPReturnsOnCall(i int, result1 error) {
	fake.UpdateDesiredLRPStub = nil
	if fake.updateDesiredLRPReturnsOnCall == nil {
		fake.updateDesiredLRPReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.updateDesiredLRPReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeInternalClient) RemoveDesiredLRP(logger lager.Logger, processGuid string) error {
	fake.removeDesiredLRPMutex.Lock()
	ret, specificReturn := fake.removeDesiredLRPReturnsOnCall[len(fake.removeDesiredLRPArgsForCall)]
	fake.removeDesiredLRPArgsForCall = append(fake.removeDesiredLRPArgsForCall, struct {
		logger      lager.Logger
		processGuid string
	}{logger, processGuid})
	fake.recordInvocation("RemoveDesiredLRP", []interface{}{logger, processGuid})
	fake.removeDesiredLRPMutex.Unlock()
	if fake.RemoveDesiredLRPStub != nil {
		return fake.RemoveDesiredLRPStub(logger, processGuid)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.removeDesiredLRPReturns.result1
}

func (fake *FakeInternalClient) RemoveDesiredLRPCallCount() int {
	fake.removeDesiredLRPMutex.RLock()
	defer fake.removeDesiredLRPMutex.RUnlock()
	return len(fake.removeDesiredLRPArgsForCall)
}

func (fake *FakeInternalClient) RemoveDesiredLRPArgsForCall(i int) (lager.Logger, string) {
	fake.removeDesiredLRPMutex.RLock()
	defer fake.removeDesiredLRPMutex.RUnlock()
	return fake.removeDesiredLRPArgsForCall[i].logger, fake.removeDesiredLRPArgsForCall[i].processGuid
}

func (fake *FakeInternalClient) RemoveDesiredLRPReturns(result1 error) {
	fake.RemoveDesiredLRPStub = nil
	fake.removeDesiredLRPReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeInternalClient) RemoveDesiredLRPReturnsOnCall(i int, result1 error) {
	fake.RemoveDesiredLRPStub = nil
	if fake.removeDesiredLRPReturnsOnCall == nil {
		fake.removeDesiredLRPReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.removeDesiredLRPReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeInternalClient) SubscribeToEvents(logger lager.Logger) (events.EventSource, error) {
	fake.subscribeToEventsMutex.Lock()
	ret, specificReturn := fake.subscribeToEventsReturnsOnCall[len(fake.subscribeToEventsArgsForCall)]
	fake.subscribeToEventsArgsForCall = append(fake.subscribeToEventsArgsForCall, struct {
		logger lager.Logger
	}{logger})
	fake.recordInvocation("SubscribeToEvents", []interface{}{logger})
	fake.subscribeToEventsMutex.Unlock()
	if fake.SubscribeToEventsStub != nil {
		return fake.SubscribeToEventsStub(logger)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.subscribeToEventsReturns.result1, fake.subscribeToEventsReturns.result2
}

func (fake *FakeInternalClient) SubscribeToEventsCallCount() int {
	fake.subscribeToEventsMutex.RLock()
	defer fake.subscribeToEventsMutex.RUnlock()
	return len(fake.subscribeToEventsArgsForCall)
}

func (fake *FakeInternalClient) SubscribeToEventsArgsForCall(i int) lager.Logger {
	fake.subscribeToEventsMutex.RLock()
	defer fake.subscribeToEventsMutex.RUnlock()
	return fake.subscribeToEventsArgsForCall[i].logger
}

func (fake *FakeInternalClient) SubscribeToEventsReturns(result1 events.EventSource, result2 error) {
	fake.SubscribeToEventsStub = nil
	fake.subscribeToEventsReturns = struct {
		result1 events.EventSource
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) SubscribeToEventsReturnsOnCall(i int, result1 events.EventSource, result2 error) {
	fake.SubscribeToEventsStub = nil
	if fake.subscribeToEventsReturnsOnCall == nil {
		fake.subscribeToEventsReturnsOnCall = make(map[int]struct {
			result1 events.EventSource
			result2 error
		})
	}
	fake.subscribeToEventsReturnsOnCall[i] = struct {
		result1 events.EventSource
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) SubscribeToTaskEvents(logger lager.Logger) (events.EventSource, error) {
	fake.subscribeToTaskEventsMutex.Lock()
	ret, specificReturn := fake.subscribeToTaskEventsReturnsOnCall[len(fake.subscribeToTaskEventsArgsForCall)]
	fake.subscribeToTaskEventsArgsForCall = append(fake.subscribeToTaskEventsArgsForCall, struct {
		logger lager.Logger
	}{logger})
	fake.recordInvocation("SubscribeToTaskEvents", []interface{}{logger})
	fake.subscribeToTaskEventsMutex.Unlock()
	if fake.SubscribeToTaskEventsStub != nil {
		return fake.SubscribeToTaskEventsStub(logger)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.subscribeToTaskEventsReturns.result1, fake.subscribeToTaskEventsReturns.result2
}

func (fake *FakeInternalClient) SubscribeToTaskEventsCallCount() int {
	fake.subscribeToTaskEventsMutex.RLock()
	defer fake.subscribeToTaskEventsMutex.RUnlock()
	return len(fake.subscribeToTaskEventsArgsForCall)
}

func (fake *FakeInternalClient) SubscribeToTaskEventsArgsForCall(i int) lager.Logger {
	fake.subscribeToTaskEventsMutex.RLock()
	defer fake.subscribeToTaskEventsMutex.RUnlock()
	return fake.subscribeToTaskEventsArgsForCall[i].logger
}

func (fake *FakeInternalClient) SubscribeToTaskEventsReturns(result1 events.EventSource, result2 error) {
	fake.SubscribeToTaskEventsStub = nil
	fake.subscribeToTaskEventsReturns = struct {
		result1 events.EventSource
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) SubscribeToTaskEventsReturnsOnCall(i int, result1 events.EventSource, result2 error) {
	fake.SubscribeToTaskEventsStub = nil
	if fake.subscribeToTaskEventsReturnsOnCall == nil {
		fake.subscribeToTaskEventsReturnsOnCall = make(map[int]struct {
			result1 events.EventSource
			result2 error
		})
	}
	fake.subscribeToTaskEventsReturnsOnCall[i] = struct {
		result1 events.EventSource
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) SubscribeToEventsByCellID(logger lager.Logger, cellId string) (events.EventSource, error) {
	fake.subscribeToEventsByCellIDMutex.Lock()
	ret, specificReturn := fake.subscribeToEventsByCellIDReturnsOnCall[len(fake.subscribeToEventsByCellIDArgsForCall)]
	fake.subscribeToEventsByCellIDArgsForCall = append(fake.subscribeToEventsByCellIDArgsForCall, struct {
		logger lager.Logger
		cellId string
	}{logger, cellId})
	fake.recordInvocation("SubscribeToEventsByCellID", []interface{}{logger, cellId})
	fake.subscribeToEventsByCellIDMutex.Unlock()
	if fake.SubscribeToEventsByCellIDStub != nil {
		return fake.SubscribeToEventsByCellIDStub(logger, cellId)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.subscribeToEventsByCellIDReturns.result1, fake.subscribeToEventsByCellIDReturns.result2
}

func (fake *FakeInternalClient) SubscribeToEventsByCellIDCallCount() int {
	fake.subscribeToEventsByCellIDMutex.RLock()
	defer fake.subscribeToEventsByCellIDMutex.RUnlock()
	return len(fake.subscribeToEventsByCellIDArgsForCall)
}

func (fake *FakeInternalClient) SubscribeToEventsByCellIDArgsForCall(i int) (lager.Logger, string) {
	fake.subscribeToEventsByCellIDMutex.RLock()
	defer fake.subscribeToEventsByCellIDMutex.RUnlock()
	return fake.subscribeToEventsByCellIDArgsForCall[i].logger, fake.subscribeToEventsByCellIDArgsForCall[i].cellId
}

func (fake *FakeInternalClient) SubscribeToEventsByCellIDReturns(result1 events.EventSource, result2 error) {
	fake.SubscribeToEventsByCellIDStub = nil
	fake.subscribeToEventsByCellIDReturns = struct {
		result1 events.EventSource
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) SubscribeToEventsByCellIDReturnsOnCall(i int, result1 events.EventSource, result2 error) {
	fake.SubscribeToEventsByCellIDStub = nil
	if fake.subscribeToEventsByCellIDReturnsOnCall == nil {
		fake.subscribeToEventsByCellIDReturnsOnCall = make(map[int]struct {
			result1 events.EventSource
			result2 error
		})
	}
	fake.subscribeToEventsByCellIDReturnsOnCall[i] = struct {
		result1 events.EventSource
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) Ping(logger lager.Logger) bool {
	fake.pingMutex.Lock()
	ret, specificReturn := fake.pingReturnsOnCall[len(fake.pingArgsForCall)]
	fake.pingArgsForCall = append(fake.pingArgsForCall, struct {
		logger lager.Logger
	}{logger})
	fake.recordInvocation("Ping", []interface{}{logger})
	fake.pingMutex.Unlock()
	if fake.PingStub != nil {
		return fake.PingStub(logger)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.pingReturns.result1
}

func (fake *FakeInternalClient) PingCallCount() int {
	fake.pingMutex.RLock()
	defer fake.pingMutex.RUnlock()
	return len(fake.pingArgsForCall)
}

func (fake *FakeInternalClient) PingArgsForCall(i int) lager.Logger {
	fake.pingMutex.RLock()
	defer fake.pingMutex.RUnlock()
	return fake.pingArgsForCall[i].logger
}

func (fake *FakeInternalClient) PingReturns(result1 bool) {
	fake.PingStub = nil
	fake.pingReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeInternalClient) PingReturnsOnCall(i int, result1 bool) {
	fake.PingStub = nil
	if fake.pingReturnsOnCall == nil {
		fake.pingReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.pingReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeInternalClient) Cells(logger lager.Logger) ([]*models.CellPresence, error) {
	fake.cellsMutex.Lock()
	ret, specificReturn := fake.cellsReturnsOnCall[len(fake.cellsArgsForCall)]
	fake.cellsArgsForCall = append(fake.cellsArgsForCall, struct {
		logger lager.Logger
	}{logger})
	fake.recordInvocation("Cells", []interface{}{logger})
	fake.cellsMutex.Unlock()
	if fake.CellsStub != nil {
		return fake.CellsStub(logger)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.cellsReturns.result1, fake.cellsReturns.result2
}

func (fake *FakeInternalClient) CellsCallCount() int {
	fake.cellsMutex.RLock()
	defer fake.cellsMutex.RUnlock()
	return len(fake.cellsArgsForCall)
}

func (fake *FakeInternalClient) CellsArgsForCall(i int) lager.Logger {
	fake.cellsMutex.RLock()
	defer fake.cellsMutex.RUnlock()
	return fake.cellsArgsForCall[i].logger
}

func (fake *FakeInternalClient) CellsReturns(result1 []*models.CellPresence, result2 error) {
	fake.CellsStub = nil
	fake.cellsReturns = struct {
		result1 []*models.CellPresence
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) CellsReturnsOnCall(i int, result1 []*models.CellPresence, result2 error) {
	fake.CellsStub = nil
	if fake.cellsReturnsOnCall == nil {
		fake.cellsReturnsOnCall = make(map[int]struct {
			result1 []*models.CellPresence
			result2 error
		})
	}
	fake.cellsReturnsOnCall[i] = struct {
		result1 []*models.CellPresence
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) ClaimActualLRP(logger lager.Logger, processGuid string, index int, instanceKey *models.ActualLRPInstanceKey) error {
	fake.claimActualLRPMutex.Lock()
	ret, specificReturn := fake.claimActualLRPReturnsOnCall[len(fake.claimActualLRPArgsForCall)]
	fake.claimActualLRPArgsForCall = append(fake.claimActualLRPArgsForCall, struct {
		logger      lager.Logger
		processGuid string
		index       int
		instanceKey *models.ActualLRPInstanceKey
	}{logger, processGuid, index, instanceKey})
	fake.recordInvocation("ClaimActualLRP", []interface{}{logger, processGuid, index, instanceKey})
	fake.claimActualLRPMutex.Unlock()
	if fake.ClaimActualLRPStub != nil {
		return fake.ClaimActualLRPStub(logger, processGuid, index, instanceKey)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.claimActualLRPReturns.result1
}

func (fake *FakeInternalClient) ClaimActualLRPCallCount() int {
	fake.claimActualLRPMutex.RLock()
	defer fake.claimActualLRPMutex.RUnlock()
	return len(fake.claimActualLRPArgsForCall)
}

func (fake *FakeInternalClient) ClaimActualLRPArgsForCall(i int) (lager.Logger, string, int, *models.ActualLRPInstanceKey) {
	fake.claimActualLRPMutex.RLock()
	defer fake.claimActualLRPMutex.RUnlock()
	return fake.claimActualLRPArgsForCall[i].logger, fake.claimActualLRPArgsForCall[i].processGuid, fake.claimActualLRPArgsForCall[i].index, fake.claimActualLRPArgsForCall[i].instanceKey
}

func (fake *FakeInternalClient) ClaimActualLRPReturns(result1 error) {
	fake.ClaimActualLRPStub = nil
	fake.claimActualLRPReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeInternalClient) ClaimActualLRPReturnsOnCall(i int, result1 error) {
	fake.ClaimActualLRPStub = nil
	if fake.claimActualLRPReturnsOnCall == nil {
		fake.claimActualLRPReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.claimActualLRPReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeInternalClient) StartActualLRP(logger lager.Logger, key *models.ActualLRPKey, instanceKey *models.ActualLRPInstanceKey, netInfo *models.ActualLRPNetInfo) error {
	fake.startActualLRPMutex.Lock()
	ret, specificReturn := fake.startActualLRPReturnsOnCall[len(fake.startActualLRPArgsForCall)]
	fake.startActualLRPArgsForCall = append(fake.startActualLRPArgsForCall, struct {
		logger      lager.Logger
		key         *models.ActualLRPKey
		instanceKey *models.ActualLRPInstanceKey
		netInfo     *models.ActualLRPNetInfo
	}{logger, key, instanceKey, netInfo})
	fake.recordInvocation("StartActualLRP", []interface{}{logger, key, instanceKey, netInfo})
	fake.startActualLRPMutex.Unlock()
	if fake.StartActualLRPStub != nil {
		return fake.StartActualLRPStub(logger, key, instanceKey, netInfo)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.startActualLRPReturns.result1
}

func (fake *FakeInternalClient) StartActualLRPCallCount() int {
	fake.startActualLRPMutex.RLock()
	defer fake.startActualLRPMutex.RUnlock()
	return len(fake.startActualLRPArgsForCall)
}

func (fake *FakeInternalClient) StartActualLRPArgsForCall(i int) (lager.Logger, *models.ActualLRPKey, *models.ActualLRPInstanceKey, *models.ActualLRPNetInfo) {
	fake.startActualLRPMutex.RLock()
	defer fake.startActualLRPMutex.RUnlock()
	return fake.startActualLRPArgsForCall[i].logger, fake.startActualLRPArgsForCall[i].key, fake.startActualLRPArgsForCall[i].instanceKey, fake.startActualLRPArgsForCall[i].netInfo
}

func (fake *FakeInternalClient) StartActualLRPReturns(result1 error) {
	fake.StartActualLRPStub = nil
	fake.startActualLRPReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeInternalClient) StartActualLRPReturnsOnCall(i int, result1 error) {
	fake.StartActualLRPStub = nil
	if fake.startActualLRPReturnsOnCall == nil {
		fake.startActualLRPReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.startActualLRPReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeInternalClient) CrashActualLRP(logger lager.Logger, key *models.ActualLRPKey, instanceKey *models.ActualLRPInstanceKey, errorMessage string) error {
	fake.crashActualLRPMutex.Lock()
	ret, specificReturn := fake.crashActualLRPReturnsOnCall[len(fake.crashActualLRPArgsForCall)]
	fake.crashActualLRPArgsForCall = append(fake.crashActualLRPArgsForCall, struct {
		logger       lager.Logger
		key          *models.ActualLRPKey
		instanceKey  *models.ActualLRPInstanceKey
		errorMessage string
	}{logger, key, instanceKey, errorMessage})
	fake.recordInvocation("CrashActualLRP", []interface{}{logger, key, instanceKey, errorMessage})
	fake.crashActualLRPMutex.Unlock()
	if fake.CrashActualLRPStub != nil {
		return fake.CrashActualLRPStub(logger, key, instanceKey, errorMessage)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.crashActualLRPReturns.result1
}

func (fake *FakeInternalClient) CrashActualLRPCallCount() int {
	fake.crashActualLRPMutex.RLock()
	defer fake.crashActualLRPMutex.RUnlock()
	return len(fake.crashActualLRPArgsForCall)
}

func (fake *FakeInternalClient) CrashActualLRPArgsForCall(i int) (lager.Logger, *models.ActualLRPKey, *models.ActualLRPInstanceKey, string) {
	fake.crashActualLRPMutex.RLock()
	defer fake.crashActualLRPMutex.RUnlock()
	return fake.crashActualLRPArgsForCall[i].logger, fake.crashActualLRPArgsForCall[i].key, fake.crashActualLRPArgsForCall[i].instanceKey, fake.crashActualLRPArgsForCall[i].errorMessage
}

func (fake *FakeInternalClient) CrashActualLRPReturns(result1 error) {
	fake.CrashActualLRPStub = nil
	fake.crashActualLRPReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeInternalClient) CrashActualLRPReturnsOnCall(i int, result1 error) {
	fake.CrashActualLRPStub = nil
	if fake.crashActualLRPReturnsOnCall == nil {
		fake.crashActualLRPReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.crashActualLRPReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeInternalClient) FailActualLRP(logger lager.Logger, key *models.ActualLRPKey, errorMessage string) error {
	fake.failActualLRPMutex.Lock()
	ret, specificReturn := fake.failActualLRPReturnsOnCall[len(fake.failActualLRPArgsForCall)]
	fake.failActualLRPArgsForCall = append(fake.failActualLRPArgsForCall, struct {
		logger       lager.Logger
		key          *models.ActualLRPKey
		errorMessage string
	}{logger, key, errorMessage})
	fake.recordInvocation("FailActualLRP", []interface{}{logger, key, errorMessage})
	fake.failActualLRPMutex.Unlock()
	if fake.FailActualLRPStub != nil {
		return fake.FailActualLRPStub(logger, key, errorMessage)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.failActualLRPReturns.result1
}

func (fake *FakeInternalClient) FailActualLRPCallCount() int {
	fake.failActualLRPMutex.RLock()
	defer fake.failActualLRPMutex.RUnlock()
	return len(fake.failActualLRPArgsForCall)
}

func (fake *FakeInternalClient) FailActualLRPArgsForCall(i int) (lager.Logger, *models.ActualLRPKey, string) {
	fake.failActualLRPMutex.RLock()
	defer fake.failActualLRPMutex.RUnlock()
	return fake.failActualLRPArgsForCall[i].logger, fake.failActualLRPArgsForCall[i].key, fake.failActualLRPArgsForCall[i].errorMessage
}

func (fake *FakeInternalClient) FailActualLRPReturns(result1 error) {
	fake.FailActualLRPStub = nil
	fake.failActualLRPReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeInternalClient) FailActualLRPReturnsOnCall(i int, result1 error) {
	fake.FailActualLRPStub = nil
	if fake.failActualLRPReturnsOnCall == nil {
		fake.failActualLRPReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.failActualLRPReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeInternalClient) RemoveActualLRP(logger lager.Logger, processGuid string, index int, instanceKey *models.ActualLRPInstanceKey) error {
	fake.removeActualLRPMutex.Lock()
	ret, specificReturn := fake.removeActualLRPReturnsOnCall[len(fake.removeActualLRPArgsForCall)]
	fake.removeActualLRPArgsForCall = append(fake.removeActualLRPArgsForCall, struct {
		logger      lager.Logger
		processGuid string
		index       int
		instanceKey *models.ActualLRPInstanceKey
	}{logger, processGuid, index, instanceKey})
	fake.recordInvocation("RemoveActualLRP", []interface{}{logger, processGuid, index, instanceKey})
	fake.removeActualLRPMutex.Unlock()
	if fake.RemoveActualLRPStub != nil {
		return fake.RemoveActualLRPStub(logger, processGuid, index, instanceKey)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.removeActualLRPReturns.result1
}

func (fake *FakeInternalClient) RemoveActualLRPCallCount() int {
	fake.removeActualLRPMutex.RLock()
	defer fake.removeActualLRPMutex.RUnlock()
	return len(fake.removeActualLRPArgsForCall)
}

func (fake *FakeInternalClient) RemoveActualLRPArgsForCall(i int) (lager.Logger, string, int, *models.ActualLRPInstanceKey) {
	fake.removeActualLRPMutex.RLock()
	defer fake.removeActualLRPMutex.RUnlock()
	return fake.removeActualLRPArgsForCall[i].logger, fake.removeActualLRPArgsForCall[i].processGuid, fake.removeActualLRPArgsForCall[i].index, fake.removeActualLRPArgsForCall[i].instanceKey
}

func (fake *FakeInternalClient) RemoveActualLRPReturns(result1 error) {
	fake.RemoveActualLRPStub = nil
	fake.removeActualLRPReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeInternalClient) RemoveActualLRPReturnsOnCall(i int, result1 error) {
	fake.RemoveActualLRPStub = nil
	if fake.removeActualLRPReturnsOnCall == nil {
		fake.removeActualLRPReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.removeActualLRPReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeInternalClient) EvacuateClaimedActualLRP(arg1 lager.Logger, arg2 *models.ActualLRPKey, arg3 *models.ActualLRPInstanceKey) (bool, error) {
	fake.evacuateClaimedActualLRPMutex.Lock()
	ret, specificReturn := fake.evacuateClaimedActualLRPReturnsOnCall[len(fake.evacuateClaimedActualLRPArgsForCall)]
	fake.evacuateClaimedActualLRPArgsForCall = append(fake.evacuateClaimedActualLRPArgsForCall, struct {
		arg1 lager.Logger
		arg2 *models.ActualLRPKey
		arg3 *models.ActualLRPInstanceKey
	}{arg1, arg2, arg3})
	fake.recordInvocation("EvacuateClaimedActualLRP", []interface{}{arg1, arg2, arg3})
	fake.evacuateClaimedActualLRPMutex.Unlock()
	if fake.EvacuateClaimedActualLRPStub != nil {
		return fake.EvacuateClaimedActualLRPStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.evacuateClaimedActualLRPReturns.result1, fake.evacuateClaimedActualLRPReturns.result2
}

func (fake *FakeInternalClient) EvacuateClaimedActualLRPCallCount() int {
	fake.evacuateClaimedActualLRPMutex.RLock()
	defer fake.evacuateClaimedActualLRPMutex.RUnlock()
	return len(fake.evacuateClaimedActualLRPArgsForCall)
}

func (fake *FakeInternalClient) EvacuateClaimedActualLRPArgsForCall(i int) (lager.Logger, *models.ActualLRPKey, *models.ActualLRPInstanceKey) {
	fake.evacuateClaimedActualLRPMutex.RLock()
	defer fake.evacuateClaimedActualLRPMutex.RUnlock()
	return fake.evacuateClaimedActualLRPArgsForCall[i].arg1, fake.evacuateClaimedActualLRPArgsForCall[i].arg2, fake.evacuateClaimedActualLRPArgsForCall[i].arg3
}

func (fake *FakeInternalClient) EvacuateClaimedActualLRPReturns(result1 bool, result2 error) {
	fake.EvacuateClaimedActualLRPStub = nil
	fake.evacuateClaimedActualLRPReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) EvacuateClaimedActualLRPReturnsOnCall(i int, result1 bool, result2 error) {
	fake.EvacuateClaimedActualLRPStub = nil
	if fake.evacuateClaimedActualLRPReturnsOnCall == nil {
		fake.evacuateClaimedActualLRPReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.evacuateClaimedActualLRPReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) EvacuateRunningActualLRP(arg1 lager.Logger, arg2 *models.ActualLRPKey, arg3 *models.ActualLRPInstanceKey, arg4 *models.ActualLRPNetInfo, arg5 uint64) (bool, error) {
	fake.evacuateRunningActualLRPMutex.Lock()
	ret, specificReturn := fake.evacuateRunningActualLRPReturnsOnCall[len(fake.evacuateRunningActualLRPArgsForCall)]
	fake.evacuateRunningActualLRPArgsForCall = append(fake.evacuateRunningActualLRPArgsForCall, struct {
		arg1 lager.Logger
		arg2 *models.ActualLRPKey
		arg3 *models.ActualLRPInstanceKey
		arg4 *models.ActualLRPNetInfo
		arg5 uint64
	}{arg1, arg2, arg3, arg4, arg5})
	fake.recordInvocation("EvacuateRunningActualLRP", []interface{}{arg1, arg2, arg3, arg4, arg5})
	fake.evacuateRunningActualLRPMutex.Unlock()
	if fake.EvacuateRunningActualLRPStub != nil {
		return fake.EvacuateRunningActualLRPStub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.evacuateRunningActualLRPReturns.result1, fake.evacuateRunningActualLRPReturns.result2
}

func (fake *FakeInternalClient) EvacuateRunningActualLRPCallCount() int {
	fake.evacuateRunningActualLRPMutex.RLock()
	defer fake.evacuateRunningActualLRPMutex.RUnlock()
	return len(fake.evacuateRunningActualLRPArgsForCall)
}

func (fake *FakeInternalClient) EvacuateRunningActualLRPArgsForCall(i int) (lager.Logger, *models.ActualLRPKey, *models.ActualLRPInstanceKey, *models.ActualLRPNetInfo, uint64) {
	fake.evacuateRunningActualLRPMutex.RLock()
	defer fake.evacuateRunningActualLRPMutex.RUnlock()
	return fake.evacuateRunningActualLRPArgsForCall[i].arg1, fake.evacuateRunningActualLRPArgsForCall[i].arg2, fake.evacuateRunningActualLRPArgsForCall[i].arg3, fake.evacuateRunningActualLRPArgsForCall[i].arg4, fake.evacuateRunningActualLRPArgsForCall[i].arg5
}

func (fake *FakeInternalClient) EvacuateRunningActualLRPReturns(result1 bool, result2 error) {
	fake.EvacuateRunningActualLRPStub = nil
	fake.evacuateRunningActualLRPReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) EvacuateRunningActualLRPReturnsOnCall(i int, result1 bool, result2 error) {
	fake.EvacuateRunningActualLRPStub = nil
	if fake.evacuateRunningActualLRPReturnsOnCall == nil {
		fake.evacuateRunningActualLRPReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.evacuateRunningActualLRPReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) EvacuateStoppedActualLRP(arg1 lager.Logger, arg2 *models.ActualLRPKey, arg3 *models.ActualLRPInstanceKey) (bool, error) {
	fake.evacuateStoppedActualLRPMutex.Lock()
	ret, specificReturn := fake.evacuateStoppedActualLRPReturnsOnCall[len(fake.evacuateStoppedActualLRPArgsForCall)]
	fake.evacuateStoppedActualLRPArgsForCall = append(fake.evacuateStoppedActualLRPArgsForCall, struct {
		arg1 lager.Logger
		arg2 *models.ActualLRPKey
		arg3 *models.ActualLRPInstanceKey
	}{arg1, arg2, arg3})
	fake.recordInvocation("EvacuateStoppedActualLRP", []interface{}{arg1, arg2, arg3})
	fake.evacuateStoppedActualLRPMutex.Unlock()
	if fake.EvacuateStoppedActualLRPStub != nil {
		return fake.EvacuateStoppedActualLRPStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.evacuateStoppedActualLRPReturns.result1, fake.evacuateStoppedActualLRPReturns.result2
}

func (fake *FakeInternalClient) EvacuateStoppedActualLRPCallCount() int {
	fake.evacuateStoppedActualLRPMutex.RLock()
	defer fake.evacuateStoppedActualLRPMutex.RUnlock()
	return len(fake.evacuateStoppedActualLRPArgsForCall)
}

func (fake *FakeInternalClient) EvacuateStoppedActualLRPArgsForCall(i int) (lager.Logger, *models.ActualLRPKey, *models.ActualLRPInstanceKey) {
	fake.evacuateStoppedActualLRPMutex.RLock()
	defer fake.evacuateStoppedActualLRPMutex.RUnlock()
	return fake.evacuateStoppedActualLRPArgsForCall[i].arg1, fake.evacuateStoppedActualLRPArgsForCall[i].arg2, fake.evacuateStoppedActualLRPArgsForCall[i].arg3
}

func (fake *FakeInternalClient) EvacuateStoppedActualLRPReturns(result1 bool, result2 error) {
	fake.EvacuateStoppedActualLRPStub = nil
	fake.evacuateStoppedActualLRPReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) EvacuateStoppedActualLRPReturnsOnCall(i int, result1 bool, result2 error) {
	fake.EvacuateStoppedActualLRPStub = nil
	if fake.evacuateStoppedActualLRPReturnsOnCall == nil {
		fake.evacuateStoppedActualLRPReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.evacuateStoppedActualLRPReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) EvacuateCrashedActualLRP(arg1 lager.Logger, arg2 *models.ActualLRPKey, arg3 *models.ActualLRPInstanceKey, arg4 string) (bool, error) {
	fake.evacuateCrashedActualLRPMutex.Lock()
	ret, specificReturn := fake.evacuateCrashedActualLRPReturnsOnCall[len(fake.evacuateCrashedActualLRPArgsForCall)]
	fake.evacuateCrashedActualLRPArgsForCall = append(fake.evacuateCrashedActualLRPArgsForCall, struct {
		arg1 lager.Logger
		arg2 *models.ActualLRPKey
		arg3 *models.ActualLRPInstanceKey
		arg4 string
	}{arg1, arg2, arg3, arg4})
	fake.recordInvocation("EvacuateCrashedActualLRP", []interface{}{arg1, arg2, arg3, arg4})
	fake.evacuateCrashedActualLRPMutex.Unlock()
	if fake.EvacuateCrashedActualLRPStub != nil {
		return fake.EvacuateCrashedActualLRPStub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.evacuateCrashedActualLRPReturns.result1, fake.evacuateCrashedActualLRPReturns.result2
}

func (fake *FakeInternalClient) EvacuateCrashedActualLRPCallCount() int {
	fake.evacuateCrashedActualLRPMutex.RLock()
	defer fake.evacuateCrashedActualLRPMutex.RUnlock()
	return len(fake.evacuateCrashedActualLRPArgsForCall)
}

func (fake *FakeInternalClient) EvacuateCrashedActualLRPArgsForCall(i int) (lager.Logger, *models.ActualLRPKey, *models.ActualLRPInstanceKey, string) {
	fake.evacuateCrashedActualLRPMutex.RLock()
	defer fake.evacuateCrashedActualLRPMutex.RUnlock()
	return fake.evacuateCrashedActualLRPArgsForCall[i].arg1, fake.evacuateCrashedActualLRPArgsForCall[i].arg2, fake.evacuateCrashedActualLRPArgsForCall[i].arg3, fake.evacuateCrashedActualLRPArgsForCall[i].arg4
}

func (fake *FakeInternalClient) EvacuateCrashedActualLRPReturns(result1 bool, result2 error) {
	fake.EvacuateCrashedActualLRPStub = nil
	fake.evacuateCrashedActualLRPReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) EvacuateCrashedActualLRPReturnsOnCall(i int, result1 bool, result2 error) {
	fake.EvacuateCrashedActualLRPStub = nil
	if fake.evacuateCrashedActualLRPReturnsOnCall == nil {
		fake.evacuateCrashedActualLRPReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.evacuateCrashedActualLRPReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) RemoveEvacuatingActualLRP(arg1 lager.Logger, arg2 *models.ActualLRPKey, arg3 *models.ActualLRPInstanceKey) error {
	fake.removeEvacuatingActualLRPMutex.Lock()
	ret, specificReturn := fake.removeEvacuatingActualLRPReturnsOnCall[len(fake.removeEvacuatingActualLRPArgsForCall)]
	fake.removeEvacuatingActualLRPArgsForCall = append(fake.removeEvacuatingActualLRPArgsForCall, struct {
		arg1 lager.Logger
		arg2 *models.ActualLRPKey
		arg3 *models.ActualLRPInstanceKey
	}{arg1, arg2, arg3})
	fake.recordInvocation("RemoveEvacuatingActualLRP", []interface{}{arg1, arg2, arg3})
	fake.removeEvacuatingActualLRPMutex.Unlock()
	if fake.RemoveEvacuatingActualLRPStub != nil {
		return fake.RemoveEvacuatingActualLRPStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.removeEvacuatingActualLRPReturns.result1
}

func (fake *FakeInternalClient) RemoveEvacuatingActualLRPCallCount() int {
	fake.removeEvacuatingActualLRPMutex.RLock()
	defer fake.removeEvacuatingActualLRPMutex.RUnlock()
	return len(fake.removeEvacuatingActualLRPArgsForCall)
}

func (fake *FakeInternalClient) RemoveEvacuatingActualLRPArgsForCall(i int) (lager.Logger, *models.ActualLRPKey, *models.ActualLRPInstanceKey) {
	fake.removeEvacuatingActualLRPMutex.RLock()
	defer fake.removeEvacuatingActualLRPMutex.RUnlock()
	return fake.removeEvacuatingActualLRPArgsForCall[i].arg1, fake.removeEvacuatingActualLRPArgsForCall[i].arg2, fake.removeEvacuatingActualLRPArgsForCall[i].arg3
}

func (fake *FakeInternalClient) RemoveEvacuatingActualLRPReturns(result1 error) {
	fake.RemoveEvacuatingActualLRPStub = nil
	fake.removeEvacuatingActualLRPReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeInternalClient) RemoveEvacuatingActualLRPReturnsOnCall(i int, result1 error) {
	fake.RemoveEvacuatingActualLRPStub = nil
	if fake.removeEvacuatingActualLRPReturnsOnCall == nil {
		fake.removeEvacuatingActualLRPReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.removeEvacuatingActualLRPReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeInternalClient) StartTask(logger lager.Logger, taskGuid string, cellID string) (bool, error) {
	fake.startTaskMutex.Lock()
	ret, specificReturn := fake.startTaskReturnsOnCall[len(fake.startTaskArgsForCall)]
	fake.startTaskArgsForCall = append(fake.startTaskArgsForCall, struct {
		logger   lager.Logger
		taskGuid string
		cellID   string
	}{logger, taskGuid, cellID})
	fake.recordInvocation("StartTask", []interface{}{logger, taskGuid, cellID})
	fake.startTaskMutex.Unlock()
	if fake.StartTaskStub != nil {
		return fake.StartTaskStub(logger, taskGuid, cellID)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.startTaskReturns.result1, fake.startTaskReturns.result2
}

func (fake *FakeInternalClient) StartTaskCallCount() int {
	fake.startTaskMutex.RLock()
	defer fake.startTaskMutex.RUnlock()
	return len(fake.startTaskArgsForCall)
}

func (fake *FakeInternalClient) StartTaskArgsForCall(i int) (lager.Logger, string, string) {
	fake.startTaskMutex.RLock()
	defer fake.startTaskMutex.RUnlock()
	return fake.startTaskArgsForCall[i].logger, fake.startTaskArgsForCall[i].taskGuid, fake.startTaskArgsForCall[i].cellID
}

func (fake *FakeInternalClient) StartTaskReturns(result1 bool, result2 error) {
	fake.StartTaskStub = nil
	fake.startTaskReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) StartTaskReturnsOnCall(i int, result1 bool, result2 error) {
	fake.StartTaskStub = nil
	if fake.startTaskReturnsOnCall == nil {
		fake.startTaskReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.startTaskReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) FailTask(logger lager.Logger, taskGuid string, failureReason string) error {
	fake.failTaskMutex.Lock()
	ret, specificReturn := fake.failTaskReturnsOnCall[len(fake.failTaskArgsForCall)]
	fake.failTaskArgsForCall = append(fake.failTaskArgsForCall, struct {
		logger        lager.Logger
		taskGuid      string
		failureReason string
	}{logger, taskGuid, failureReason})
	fake.recordInvocation("FailTask", []interface{}{logger, taskGuid, failureReason})
	fake.failTaskMutex.Unlock()
	if fake.FailTaskStub != nil {
		return fake.FailTaskStub(logger, taskGuid, failureReason)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.failTaskReturns.result1
}

func (fake *FakeInternalClient) FailTaskCallCount() int {
	fake.failTaskMutex.RLock()
	defer fake.failTaskMutex.RUnlock()
	return len(fake.failTaskArgsForCall)
}

func (fake *FakeInternalClient) FailTaskArgsForCall(i int) (lager.Logger, string, string) {
	fake.failTaskMutex.RLock()
	defer fake.failTaskMutex.RUnlock()
	return fake.failTaskArgsForCall[i].logger, fake.failTaskArgsForCall[i].taskGuid, fake.failTaskArgsForCall[i].failureReason
}

func (fake *FakeInternalClient) FailTaskReturns(result1 error) {
	fake.FailTaskStub = nil
	fake.failTaskReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeInternalClient) FailTaskReturnsOnCall(i int, result1 error) {
	fake.FailTaskStub = nil
	if fake.failTaskReturnsOnCall == nil {
		fake.failTaskReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.failTaskReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeInternalClient) CompleteTask(logger lager.Logger, taskGuid string, cellId string, failed bool, failureReason string, result string) error {
	fake.completeTaskMutex.Lock()
	ret, specificReturn := fake.completeTaskReturnsOnCall[len(fake.completeTaskArgsForCall)]
	fake.completeTaskArgsForCall = append(fake.completeTaskArgsForCall, struct {
		logger        lager.Logger
		taskGuid      string
		cellId        string
		failed        bool
		failureReason string
		result        string
	}{logger, taskGuid, cellId, failed, failureReason, result})
	fake.recordInvocation("CompleteTask", []interface{}{logger, taskGuid, cellId, failed, failureReason, result})
	fake.completeTaskMutex.Unlock()
	if fake.CompleteTaskStub != nil {
		return fake.CompleteTaskStub(logger, taskGuid, cellId, failed, failureReason, result)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.completeTaskReturns.result1
}

func (fake *FakeInternalClient) CompleteTaskCallCount() int {
	fake.completeTaskMutex.RLock()
	defer fake.completeTaskMutex.RUnlock()
	return len(fake.completeTaskArgsForCall)
}

func (fake *FakeInternalClient) CompleteTaskArgsForCall(i int) (lager.Logger, string, string, bool, string, string) {
	fake.completeTaskMutex.RLock()
	defer fake.completeTaskMutex.RUnlock()
	return fake.completeTaskArgsForCall[i].logger, fake.completeTaskArgsForCall[i].taskGuid, fake.completeTaskArgsForCall[i].cellId, fake.completeTaskArgsForCall[i].failed, fake.completeTaskArgsForCall[i].failureReason, fake.completeTaskArgsForCall[i].result
}

func (fake *FakeInternalClient) CompleteTaskReturns(result1 error) {
	fake.CompleteTaskStub = nil
	fake.completeTaskReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeInternalClient) CompleteTaskReturnsOnCall(i int, result1 error) {
	fake.CompleteTaskStub = nil
	if fake.completeTaskReturnsOnCall == nil {
		fake.completeTaskReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.completeTaskReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeInternalClient) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.desireTaskMutex.RLock()
	defer fake.desireTaskMutex.RUnlock()
	fake.tasksMutex.RLock()
	defer fake.tasksMutex.RUnlock()
	fake.tasksWithFilterMutex.RLock()
	defer fake.tasksWithFilterMutex.RUnlock()
	fake.tasksByDomainMutex.RLock()
	defer fake.tasksByDomainMutex.RUnlock()
	fake.tasksByCellIDMutex.RLock()
	defer fake.tasksByCellIDMutex.RUnlock()
	fake.taskByGuidMutex.RLock()
	defer fake.taskByGuidMutex.RUnlock()
	fake.cancelTaskMutex.RLock()
	defer fake.cancelTaskMutex.RUnlock()
	fake.resolvingTaskMutex.RLock()
	defer fake.resolvingTaskMutex.RUnlock()
	fake.deleteTaskMutex.RLock()
	defer fake.deleteTaskMutex.RUnlock()
	fake.domainsMutex.RLock()
	defer fake.domainsMutex.RUnlock()
	fake.upsertDomainMutex.RLock()
	defer fake.upsertDomainMutex.RUnlock()
	fake.actualLRPGroupsMutex.RLock()
	defer fake.actualLRPGroupsMutex.RUnlock()
	fake.actualLRPGroupsByProcessGuidMutex.RLock()
	defer fake.actualLRPGroupsByProcessGuidMutex.RUnlock()
	fake.actualLRPGroupByProcessGuidAndIndexMutex.RLock()
	defer fake.actualLRPGroupByProcessGuidAndIndexMutex.RUnlock()
	fake.retireActualLRPMutex.RLock()
	defer fake.retireActualLRPMutex.RUnlock()
	fake.desiredLRPsMutex.RLock()
	defer fake.desiredLRPsMutex.RUnlock()
	fake.desiredLRPByProcessGuidMutex.RLock()
	defer fake.desiredLRPByProcessGuidMutex.RUnlock()
	fake.desiredLRPSchedulingInfosMutex.RLock()
	defer fake.desiredLRPSchedulingInfosMutex.RUnlock()
	fake.desireLRPMutex.RLock()
	defer fake.desireLRPMutex.RUnlock()
	fake.updateDesiredLRPMutex.RLock()
	defer fake.updateDesiredLRPMutex.RUnlock()
	fake.removeDesiredLRPMutex.RLock()
	defer fake.removeDesiredLRPMutex.RUnlock()
	fake.subscribeToEventsMutex.RLock()
	defer fake.subscribeToEventsMutex.RUnlock()
	fake.subscribeToTaskEventsMutex.RLock()
	defer fake.subscribeToTaskEventsMutex.RUnlock()
	fake.subscribeToEventsByCellIDMutex.RLock()
	defer fake.subscribeToEventsByCellIDMutex.RUnlock()
	fake.pingMutex.RLock()
	defer fake.pingMutex.RUnlock()
	fake.cellsMutex.RLock()
	defer fake.cellsMutex.RUnlock()
	fake.claimActualLRPMutex.RLock()
	defer fake.claimActualLRPMutex.RUnlock()
	fake.startActualLRPMutex.RLock()
	defer fake.startActualLRPMutex.RUnlock()
	fake.crashActualLRPMutex.RLock()
	defer fake.crashActualLRPMutex.RUnlock()
	fake.failActualLRPMutex.RLock()
	defer fake.failActualLRPMutex.RUnlock()
	fake.removeActualLRPMutex.RLock()
	defer fake.removeActualLRPMutex.RUnlock()
	fake.evacuateClaimedActualLRPMutex.RLock()
	defer fake.evacuateClaimedActualLRPMutex.RUnlock()
	fake.evacuateRunningActualLRPMutex.RLock()
	defer fake.evacuateRunningActualLRPMutex.RUnlock()
	fake.evacuateStoppedActualLRPMutex.RLock()
	defer fake.evacuateStoppedActualLRPMutex.RUnlock()
	fake.evacuateCrashedActualLRPMutex.RLock()
	defer fake.evacuateCrashedActualLRPMutex.RUnlock()
	fake.removeEvacuatingActualLRPMutex.RLock()
	defer fake.removeEvacuatingActualLRPMutex.RUnlock()
	fake.startTaskMutex.RLock()
	defer fake.startTaskMutex.RUnlock()
	fake.failTaskMutex.RLock()
	defer fake.failTaskMutex.RUnlock()
	fake.completeTaskMutex.RLock()
	defer fake.completeTaskMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeInternalClient) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ bbs.InternalClient = new(FakeInternalClient)
