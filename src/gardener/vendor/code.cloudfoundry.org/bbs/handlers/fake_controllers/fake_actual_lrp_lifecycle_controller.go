// Code generated by counterfeiter. DO NOT EDIT.
package fake_controllers

import (
	"sync"

	"code.cloudfoundry.org/bbs/handlers"
	"code.cloudfoundry.org/bbs/models"
	"code.cloudfoundry.org/lager"
)

type FakeActualLRPLifecycleController struct {
	ClaimActualLRPStub        func(logger lager.Logger, processGuid string, index int32, actualLRPInstanceKey *models.ActualLRPInstanceKey) error
	claimActualLRPMutex       sync.RWMutex
	claimActualLRPArgsForCall []struct {
		logger               lager.Logger
		processGuid          string
		index                int32
		actualLRPInstanceKey *models.ActualLRPInstanceKey
	}
	claimActualLRPReturns struct {
		result1 error
	}
	claimActualLRPReturnsOnCall map[int]struct {
		result1 error
	}
	StartActualLRPStub        func(logger lager.Logger, actualLRPKey *models.ActualLRPKey, actualLRPInstanceKey *models.ActualLRPInstanceKey, actualLRPNetInfo *models.ActualLRPNetInfo) error
	startActualLRPMutex       sync.RWMutex
	startActualLRPArgsForCall []struct {
		logger               lager.Logger
		actualLRPKey         *models.ActualLRPKey
		actualLRPInstanceKey *models.ActualLRPInstanceKey
		actualLRPNetInfo     *models.ActualLRPNetInfo
	}
	startActualLRPReturns struct {
		result1 error
	}
	startActualLRPReturnsOnCall map[int]struct {
		result1 error
	}
	CrashActualLRPStub        func(logger lager.Logger, actualLRPKey *models.ActualLRPKey, actualLRPInstanceKey *models.ActualLRPInstanceKey, errorMessage string) error
	crashActualLRPMutex       sync.RWMutex
	crashActualLRPArgsForCall []struct {
		logger               lager.Logger
		actualLRPKey         *models.ActualLRPKey
		actualLRPInstanceKey *models.ActualLRPInstanceKey
		errorMessage         string
	}
	crashActualLRPReturns struct {
		result1 error
	}
	crashActualLRPReturnsOnCall map[int]struct {
		result1 error
	}
	FailActualLRPStub        func(logger lager.Logger, key *models.ActualLRPKey, errorMessage string) error
	failActualLRPMutex       sync.RWMutex
	failActualLRPArgsForCall []struct {
		logger       lager.Logger
		key          *models.ActualLRPKey
		errorMessage string
	}
	failActualLRPReturns struct {
		result1 error
	}
	failActualLRPReturnsOnCall map[int]struct {
		result1 error
	}
	RemoveActualLRPStub        func(logger lager.Logger, processGuid string, index int32, instanceKey *models.ActualLRPInstanceKey) error
	removeActualLRPMutex       sync.RWMutex
	removeActualLRPArgsForCall []struct {
		logger      lager.Logger
		processGuid string
		index       int32
		instanceKey *models.ActualLRPInstanceKey
	}
	removeActualLRPReturns struct {
		result1 error
	}
	removeActualLRPReturnsOnCall map[int]struct {
		result1 error
	}
	RetireActualLRPStub        func(logger lager.Logger, key *models.ActualLRPKey) error
	retireActualLRPMutex       sync.RWMutex
	retireActualLRPArgsForCall []struct {
		logger lager.Logger
		key    *models.ActualLRPKey
	}
	retireActualLRPReturns struct {
		result1 error
	}
	retireActualLRPReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeActualLRPLifecycleController) ClaimActualLRP(logger lager.Logger, processGuid string, index int32, actualLRPInstanceKey *models.ActualLRPInstanceKey) error {
	fake.claimActualLRPMutex.Lock()
	ret, specificReturn := fake.claimActualLRPReturnsOnCall[len(fake.claimActualLRPArgsForCall)]
	fake.claimActualLRPArgsForCall = append(fake.claimActualLRPArgsForCall, struct {
		logger               lager.Logger
		processGuid          string
		index                int32
		actualLRPInstanceKey *models.ActualLRPInstanceKey
	}{logger, processGuid, index, actualLRPInstanceKey})
	fake.recordInvocation("ClaimActualLRP", []interface{}{logger, processGuid, index, actualLRPInstanceKey})
	fake.claimActualLRPMutex.Unlock()
	if fake.ClaimActualLRPStub != nil {
		return fake.ClaimActualLRPStub(logger, processGuid, index, actualLRPInstanceKey)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.claimActualLRPReturns.result1
}

func (fake *FakeActualLRPLifecycleController) ClaimActualLRPCallCount() int {
	fake.claimActualLRPMutex.RLock()
	defer fake.claimActualLRPMutex.RUnlock()
	return len(fake.claimActualLRPArgsForCall)
}

func (fake *FakeActualLRPLifecycleController) ClaimActualLRPArgsForCall(i int) (lager.Logger, string, int32, *models.ActualLRPInstanceKey) {
	fake.claimActualLRPMutex.RLock()
	defer fake.claimActualLRPMutex.RUnlock()
	return fake.claimActualLRPArgsForCall[i].logger, fake.claimActualLRPArgsForCall[i].processGuid, fake.claimActualLRPArgsForCall[i].index, fake.claimActualLRPArgsForCall[i].actualLRPInstanceKey
}

func (fake *FakeActualLRPLifecycleController) ClaimActualLRPReturns(result1 error) {
	fake.ClaimActualLRPStub = nil
	fake.claimActualLRPReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeActualLRPLifecycleController) ClaimActualLRPReturnsOnCall(i int, result1 error) {
	fake.ClaimActualLRPStub = nil
	if fake.claimActualLRPReturnsOnCall == nil {
		fake.claimActualLRPReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.claimActualLRPReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeActualLRPLifecycleController) StartActualLRP(logger lager.Logger, actualLRPKey *models.ActualLRPKey, actualLRPInstanceKey *models.ActualLRPInstanceKey, actualLRPNetInfo *models.ActualLRPNetInfo) error {
	fake.startActualLRPMutex.Lock()
	ret, specificReturn := fake.startActualLRPReturnsOnCall[len(fake.startActualLRPArgsForCall)]
	fake.startActualLRPArgsForCall = append(fake.startActualLRPArgsForCall, struct {
		logger               lager.Logger
		actualLRPKey         *models.ActualLRPKey
		actualLRPInstanceKey *models.ActualLRPInstanceKey
		actualLRPNetInfo     *models.ActualLRPNetInfo
	}{logger, actualLRPKey, actualLRPInstanceKey, actualLRPNetInfo})
	fake.recordInvocation("StartActualLRP", []interface{}{logger, actualLRPKey, actualLRPInstanceKey, actualLRPNetInfo})
	fake.startActualLRPMutex.Unlock()
	if fake.StartActualLRPStub != nil {
		return fake.StartActualLRPStub(logger, actualLRPKey, actualLRPInstanceKey, actualLRPNetInfo)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.startActualLRPReturns.result1
}

func (fake *FakeActualLRPLifecycleController) StartActualLRPCallCount() int {
	fake.startActualLRPMutex.RLock()
	defer fake.startActualLRPMutex.RUnlock()
	return len(fake.startActualLRPArgsForCall)
}

func (fake *FakeActualLRPLifecycleController) StartActualLRPArgsForCall(i int) (lager.Logger, *models.ActualLRPKey, *models.ActualLRPInstanceKey, *models.ActualLRPNetInfo) {
	fake.startActualLRPMutex.RLock()
	defer fake.startActualLRPMutex.RUnlock()
	return fake.startActualLRPArgsForCall[i].logger, fake.startActualLRPArgsForCall[i].actualLRPKey, fake.startActualLRPArgsForCall[i].actualLRPInstanceKey, fake.startActualLRPArgsForCall[i].actualLRPNetInfo
}

func (fake *FakeActualLRPLifecycleController) StartActualLRPReturns(result1 error) {
	fake.StartActualLRPStub = nil
	fake.startActualLRPReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeActualLRPLifecycleController) StartActualLRPReturnsOnCall(i int, result1 error) {
	fake.StartActualLRPStub = nil
	if fake.startActualLRPReturnsOnCall == nil {
		fake.startActualLRPReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.startActualLRPReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeActualLRPLifecycleController) CrashActualLRP(logger lager.Logger, actualLRPKey *models.ActualLRPKey, actualLRPInstanceKey *models.ActualLRPInstanceKey, errorMessage string) error {
	fake.crashActualLRPMutex.Lock()
	ret, specificReturn := fake.crashActualLRPReturnsOnCall[len(fake.crashActualLRPArgsForCall)]
	fake.crashActualLRPArgsForCall = append(fake.crashActualLRPArgsForCall, struct {
		logger               lager.Logger
		actualLRPKey         *models.ActualLRPKey
		actualLRPInstanceKey *models.ActualLRPInstanceKey
		errorMessage         string
	}{logger, actualLRPKey, actualLRPInstanceKey, errorMessage})
	fake.recordInvocation("CrashActualLRP", []interface{}{logger, actualLRPKey, actualLRPInstanceKey, errorMessage})
	fake.crashActualLRPMutex.Unlock()
	if fake.CrashActualLRPStub != nil {
		return fake.CrashActualLRPStub(logger, actualLRPKey, actualLRPInstanceKey, errorMessage)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.crashActualLRPReturns.result1
}

func (fake *FakeActualLRPLifecycleController) CrashActualLRPCallCount() int {
	fake.crashActualLRPMutex.RLock()
	defer fake.crashActualLRPMutex.RUnlock()
	return len(fake.crashActualLRPArgsForCall)
}

func (fake *FakeActualLRPLifecycleController) CrashActualLRPArgsForCall(i int) (lager.Logger, *models.ActualLRPKey, *models.ActualLRPInstanceKey, string) {
	fake.crashActualLRPMutex.RLock()
	defer fake.crashActualLRPMutex.RUnlock()
	return fake.crashActualLRPArgsForCall[i].logger, fake.crashActualLRPArgsForCall[i].actualLRPKey, fake.crashActualLRPArgsForCall[i].actualLRPInstanceKey, fake.crashActualLRPArgsForCall[i].errorMessage
}

func (fake *FakeActualLRPLifecycleController) CrashActualLRPReturns(result1 error) {
	fake.CrashActualLRPStub = nil
	fake.crashActualLRPReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeActualLRPLifecycleController) CrashActualLRPReturnsOnCall(i int, result1 error) {
	fake.CrashActualLRPStub = nil
	if fake.crashActualLRPReturnsOnCall == nil {
		fake.crashActualLRPReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.crashActualLRPReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeActualLRPLifecycleController) FailActualLRP(logger lager.Logger, key *models.ActualLRPKey, errorMessage string) error {
	fake.failActualLRPMutex.Lock()
	ret, specificReturn := fake.failActualLRPReturnsOnCall[len(fake.failActualLRPArgsForCall)]
	fake.failActualLRPArgsForCall = append(fake.failActualLRPArgsForCall, struct {
		logger       lager.Logger
		key          *models.ActualLRPKey
		errorMessage string
	}{logger, key, errorMessage})
	fake.recordInvocation("FailActualLRP", []interface{}{logger, key, errorMessage})
	fake.failActualLRPMutex.Unlock()
	if fake.FailActualLRPStub != nil {
		return fake.FailActualLRPStub(logger, key, errorMessage)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.failActualLRPReturns.result1
}

func (fake *FakeActualLRPLifecycleController) FailActualLRPCallCount() int {
	fake.failActualLRPMutex.RLock()
	defer fake.failActualLRPMutex.RUnlock()
	return len(fake.failActualLRPArgsForCall)
}

func (fake *FakeActualLRPLifecycleController) FailActualLRPArgsForCall(i int) (lager.Logger, *models.ActualLRPKey, string) {
	fake.failActualLRPMutex.RLock()
	defer fake.failActualLRPMutex.RUnlock()
	return fake.failActualLRPArgsForCall[i].logger, fake.failActualLRPArgsForCall[i].key, fake.failActualLRPArgsForCall[i].errorMessage
}

func (fake *FakeActualLRPLifecycleController) FailActualLRPReturns(result1 error) {
	fake.FailActualLRPStub = nil
	fake.failActualLRPReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeActualLRPLifecycleController) FailActualLRPReturnsOnCall(i int, result1 error) {
	fake.FailActualLRPStub = nil
	if fake.failActualLRPReturnsOnCall == nil {
		fake.failActualLRPReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.failActualLRPReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeActualLRPLifecycleController) RemoveActualLRP(logger lager.Logger, processGuid string, index int32, instanceKey *models.ActualLRPInstanceKey) error {
	fake.removeActualLRPMutex.Lock()
	ret, specificReturn := fake.removeActualLRPReturnsOnCall[len(fake.removeActualLRPArgsForCall)]
	fake.removeActualLRPArgsForCall = append(fake.removeActualLRPArgsForCall, struct {
		logger      lager.Logger
		processGuid string
		index       int32
		instanceKey *models.ActualLRPInstanceKey
	}{logger, processGuid, index, instanceKey})
	fake.recordInvocation("RemoveActualLRP", []interface{}{logger, processGuid, index, instanceKey})
	fake.removeActualLRPMutex.Unlock()
	if fake.RemoveActualLRPStub != nil {
		return fake.RemoveActualLRPStub(logger, processGuid, index, instanceKey)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.removeActualLRPReturns.result1
}

func (fake *FakeActualLRPLifecycleController) RemoveActualLRPCallCount() int {
	fake.removeActualLRPMutex.RLock()
	defer fake.removeActualLRPMutex.RUnlock()
	return len(fake.removeActualLRPArgsForCall)
}

func (fake *FakeActualLRPLifecycleController) RemoveActualLRPArgsForCall(i int) (lager.Logger, string, int32, *models.ActualLRPInstanceKey) {
	fake.removeActualLRPMutex.RLock()
	defer fake.removeActualLRPMutex.RUnlock()
	return fake.removeActualLRPArgsForCall[i].logger, fake.removeActualLRPArgsForCall[i].processGuid, fake.removeActualLRPArgsForCall[i].index, fake.removeActualLRPArgsForCall[i].instanceKey
}

func (fake *FakeActualLRPLifecycleController) RemoveActualLRPReturns(result1 error) {
	fake.RemoveActualLRPStub = nil
	fake.removeActualLRPReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeActualLRPLifecycleController) RemoveActualLRPReturnsOnCall(i int, result1 error) {
	fake.RemoveActualLRPStub = nil
	if fake.removeActualLRPReturnsOnCall == nil {
		fake.removeActualLRPReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.removeActualLRPReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeActualLRPLifecycleController) RetireActualLRP(logger lager.Logger, key *models.ActualLRPKey) error {
	fake.retireActualLRPMutex.Lock()
	ret, specificReturn := fake.retireActualLRPReturnsOnCall[len(fake.retireActualLRPArgsForCall)]
	fake.retireActualLRPArgsForCall = append(fake.retireActualLRPArgsForCall, struct {
		logger lager.Logger
		key    *models.ActualLRPKey
	}{logger, key})
	fake.recordInvocation("RetireActualLRP", []interface{}{logger, key})
	fake.retireActualLRPMutex.Unlock()
	if fake.RetireActualLRPStub != nil {
		return fake.RetireActualLRPStub(logger, key)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.retireActualLRPReturns.result1
}

func (fake *FakeActualLRPLifecycleController) RetireActualLRPCallCount() int {
	fake.retireActualLRPMutex.RLock()
	defer fake.retireActualLRPMutex.RUnlock()
	return len(fake.retireActualLRPArgsForCall)
}

func (fake *FakeActualLRPLifecycleController) RetireActualLRPArgsForCall(i int) (lager.Logger, *models.ActualLRPKey) {
	fake.retireActualLRPMutex.RLock()
	defer fake.retireActualLRPMutex.RUnlock()
	return fake.retireActualLRPArgsForCall[i].logger, fake.retireActualLRPArgsForCall[i].key
}

func (fake *FakeActualLRPLifecycleController) RetireActualLRPReturns(result1 error) {
	fake.RetireActualLRPStub = nil
	fake.retireActualLRPReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeActualLRPLifecycleController) RetireActualLRPReturnsOnCall(i int, result1 error) {
	fake.RetireActualLRPStub = nil
	if fake.retireActualLRPReturnsOnCall == nil {
		fake.retireActualLRPReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.retireActualLRPReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeActualLRPLifecycleController) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.claimActualLRPMutex.RLock()
	defer fake.claimActualLRPMutex.RUnlock()
	fake.startActualLRPMutex.RLock()
	defer fake.startActualLRPMutex.RUnlock()
	fake.crashActualLRPMutex.RLock()
	defer fake.crashActualLRPMutex.RUnlock()
	fake.failActualLRPMutex.RLock()
	defer fake.failActualLRPMutex.RUnlock()
	fake.removeActualLRPMutex.RLock()
	defer fake.removeActualLRPMutex.RUnlock()
	fake.retireActualLRPMutex.RLock()
	defer fake.retireActualLRPMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeActualLRPLifecycleController) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ handlers.ActualLRPLifecycleController = new(FakeActualLRPLifecycleController)
