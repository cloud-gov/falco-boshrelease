// Code generated by protoc-gen-gogo.
// source: desired_lrp.proto
// DO NOT EDIT!

package models

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"

import bytes "bytes"

import strings "strings"
import reflect "reflect"
import github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type DesiredLRPSchedulingInfo struct {
	DesiredLRPKey      `protobuf:"bytes,1,opt,name=desired_lrp_key,json=desiredLrpKey,embedded=desired_lrp_key" json:""`
	Annotation         string `protobuf:"bytes,2,opt,name=annotation" json:"annotation"`
	Instances          int32  `protobuf:"varint,3,opt,name=instances" json:"instances"`
	DesiredLRPResource `protobuf:"bytes,4,opt,name=desired_lrp_resource,json=desiredLrpResource,embedded=desired_lrp_resource" json:""`
	Routes             Routes `protobuf:"bytes,5,opt,name=routes,customtype=Routes" json:"routes"`
	ModificationTag    `protobuf:"bytes,6,opt,name=modification_tag,json=modificationTag,embedded=modification_tag" json:""`
	VolumePlacement    *VolumePlacement `protobuf:"bytes,7,opt,name=volume_placement,json=volumePlacement" json:"volume_placement,omitempty"`
	PlacementTags      []string         `protobuf:"bytes,8,rep,name=PlacementTags" json:"placement_tags,omitempty"`
}

func (m *DesiredLRPSchedulingInfo) Reset()      { *m = DesiredLRPSchedulingInfo{} }
func (*DesiredLRPSchedulingInfo) ProtoMessage() {}
func (*DesiredLRPSchedulingInfo) Descriptor() ([]byte, []int) {
	return fileDescriptorDesiredLrp, []int{0}
}

func (m *DesiredLRPSchedulingInfo) GetAnnotation() string {
	if m != nil {
		return m.Annotation
	}
	return ""
}

func (m *DesiredLRPSchedulingInfo) GetInstances() int32 {
	if m != nil {
		return m.Instances
	}
	return 0
}

func (m *DesiredLRPSchedulingInfo) GetVolumePlacement() *VolumePlacement {
	if m != nil {
		return m.VolumePlacement
	}
	return nil
}

func (m *DesiredLRPSchedulingInfo) GetPlacementTags() []string {
	if m != nil {
		return m.PlacementTags
	}
	return nil
}

type DesiredLRPRunInfo struct {
	DesiredLRPKey                 `protobuf:"bytes,1,opt,name=desired_lrp_key,json=desiredLrpKey,embedded=desired_lrp_key" json:""`
	EnvironmentVariables          []EnvironmentVariable  `protobuf:"bytes,2,rep,name=environment_variables,json=environmentVariables" json:"env"`
	Setup                         *Action                `protobuf:"bytes,3,opt,name=setup" json:"setup,omitempty"`
	Action                        *Action                `protobuf:"bytes,4,opt,name=action" json:"action,omitempty"`
	Monitor                       *Action                `protobuf:"bytes,5,opt,name=monitor" json:"monitor,omitempty"`
	DeprecatedStartTimeoutS       uint32                 `protobuf:"varint,6,opt,name=deprecated_start_timeout_s,json=deprecatedStartTimeoutS" json:"start_timeout,omitempty"`
	Privileged                    bool                   `protobuf:"varint,7,opt,name=privileged" json:"privileged"`
	CpuWeight                     uint32                 `protobuf:"varint,8,opt,name=cpu_weight,json=cpuWeight" json:"cpu_weight"`
	Ports                         []uint32               `protobuf:"varint,9,rep,name=ports" json:"ports,omitempty"`
	EgressRules                   []SecurityGroupRule    `protobuf:"bytes,10,rep,name=egress_rules,json=egressRules" json:"egress_rules"`
	LogSource                     string                 `protobuf:"bytes,11,opt,name=log_source,json=logSource" json:"log_source"`
	MetricsGuid                   string                 `protobuf:"bytes,12,opt,name=metrics_guid,json=metricsGuid" json:"metrics_guid"`
	CreatedAt                     int64                  `protobuf:"varint,13,opt,name=created_at,json=createdAt" json:"created_at"`
	CachedDependencies            []*CachedDependency    `protobuf:"bytes,14,rep,name=cached_dependencies,json=cachedDependencies" json:"cached_dependencies,omitempty"`
	LegacyDownloadUser            string                 `protobuf:"bytes,15,opt,name=legacy_download_user,json=legacyDownloadUser" json:"legacy_download_user,omitempty"`
	TrustedSystemCertificatesPath string                 `protobuf:"bytes,16,opt,name=trusted_system_certificates_path,json=trustedSystemCertificatesPath" json:"trusted_system_certificates_path,omitempty"`
	VolumeMounts                  []*VolumeMount         `protobuf:"bytes,17,rep,name=volume_mounts,json=volumeMounts" json:"volume_mounts,omitempty"`
	Network                       *Network               `protobuf:"bytes,18,opt,name=network" json:"network,omitempty"`
	StartTimeoutMs                int64                  `protobuf:"varint,19,opt,name=start_timeout_ms,json=startTimeoutMs" json:"start_timeout_ms"`
	CertificateProperties         *CertificateProperties `protobuf:"bytes,20,opt,name=certificate_properties,json=certificateProperties" json:"certificate_properties,omitempty"`
	ImageUsername                 string                 `protobuf:"bytes,21,opt,name=image_username,json=imageUsername" json:"image_username,omitempty"`
	ImagePassword                 string                 `protobuf:"bytes,22,opt,name=image_password,json=imagePassword" json:"image_password,omitempty"`
	CheckDefinition               *CheckDefinition       `protobuf:"bytes,23,opt,name=check_definition,json=checkDefinition" json:"check_definition,omitempty"`
}

func (m *DesiredLRPRunInfo) Reset()                    { *m = DesiredLRPRunInfo{} }
func (*DesiredLRPRunInfo) ProtoMessage()               {}
func (*DesiredLRPRunInfo) Descriptor() ([]byte, []int) { return fileDescriptorDesiredLrp, []int{1} }

func (m *DesiredLRPRunInfo) GetEnvironmentVariables() []EnvironmentVariable {
	if m != nil {
		return m.EnvironmentVariables
	}
	return nil
}

func (m *DesiredLRPRunInfo) GetSetup() *Action {
	if m != nil {
		return m.Setup
	}
	return nil
}

func (m *DesiredLRPRunInfo) GetAction() *Action {
	if m != nil {
		return m.Action
	}
	return nil
}

func (m *DesiredLRPRunInfo) GetMonitor() *Action {
	if m != nil {
		return m.Monitor
	}
	return nil
}

func (m *DesiredLRPRunInfo) GetDeprecatedStartTimeoutS() uint32 {
	if m != nil {
		return m.DeprecatedStartTimeoutS
	}
	return 0
}

func (m *DesiredLRPRunInfo) GetPrivileged() bool {
	if m != nil {
		return m.Privileged
	}
	return false
}

func (m *DesiredLRPRunInfo) GetCpuWeight() uint32 {
	if m != nil {
		return m.CpuWeight
	}
	return 0
}

func (m *DesiredLRPRunInfo) GetPorts() []uint32 {
	if m != nil {
		return m.Ports
	}
	return nil
}

func (m *DesiredLRPRunInfo) GetEgressRules() []SecurityGroupRule {
	if m != nil {
		return m.EgressRules
	}
	return nil
}

func (m *DesiredLRPRunInfo) GetLogSource() string {
	if m != nil {
		return m.LogSource
	}
	return ""
}

func (m *DesiredLRPRunInfo) GetMetricsGuid() string {
	if m != nil {
		return m.MetricsGuid
	}
	return ""
}

func (m *DesiredLRPRunInfo) GetCreatedAt() int64 {
	if m != nil {
		return m.CreatedAt
	}
	return 0
}

func (m *DesiredLRPRunInfo) GetCachedDependencies() []*CachedDependency {
	if m != nil {
		return m.CachedDependencies
	}
	return nil
}

func (m *DesiredLRPRunInfo) GetLegacyDownloadUser() string {
	if m != nil {
		return m.LegacyDownloadUser
	}
	return ""
}

func (m *DesiredLRPRunInfo) GetTrustedSystemCertificatesPath() string {
	if m != nil {
		return m.TrustedSystemCertificatesPath
	}
	return ""
}

func (m *DesiredLRPRunInfo) GetVolumeMounts() []*VolumeMount {
	if m != nil {
		return m.VolumeMounts
	}
	return nil
}

func (m *DesiredLRPRunInfo) GetNetwork() *Network {
	if m != nil {
		return m.Network
	}
	return nil
}

func (m *DesiredLRPRunInfo) GetStartTimeoutMs() int64 {
	if m != nil {
		return m.StartTimeoutMs
	}
	return 0
}

func (m *DesiredLRPRunInfo) GetCertificateProperties() *CertificateProperties {
	if m != nil {
		return m.CertificateProperties
	}
	return nil
}

func (m *DesiredLRPRunInfo) GetImageUsername() string {
	if m != nil {
		return m.ImageUsername
	}
	return ""
}

func (m *DesiredLRPRunInfo) GetImagePassword() string {
	if m != nil {
		return m.ImagePassword
	}
	return ""
}

func (m *DesiredLRPRunInfo) GetCheckDefinition() *CheckDefinition {
	if m != nil {
		return m.CheckDefinition
	}
	return nil
}

// helper message for marshalling routes
type ProtoRoutes struct {
	Routes map[string][]byte `protobuf:"bytes,1,rep,name=routes" json:"routes,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *ProtoRoutes) Reset()                    { *m = ProtoRoutes{} }
func (*ProtoRoutes) ProtoMessage()               {}
func (*ProtoRoutes) Descriptor() ([]byte, []int) { return fileDescriptorDesiredLrp, []int{2} }

func (m *ProtoRoutes) GetRoutes() map[string][]byte {
	if m != nil {
		return m.Routes
	}
	return nil
}

type DesiredLRPUpdate struct {
	Instances  *int32  `protobuf:"varint,1,opt,name=instances" json:"instances,omitempty"`
	Routes     *Routes `protobuf:"bytes,2,opt,name=routes,customtype=Routes" json:"routes,omitempty"`
	Annotation *string `protobuf:"bytes,3,opt,name=annotation" json:"annotation,omitempty"`
}

func (m *DesiredLRPUpdate) Reset()                    { *m = DesiredLRPUpdate{} }
func (*DesiredLRPUpdate) ProtoMessage()               {}
func (*DesiredLRPUpdate) Descriptor() ([]byte, []int) { return fileDescriptorDesiredLrp, []int{3} }

func (m *DesiredLRPUpdate) GetInstances() int32 {
	if m != nil && m.Instances != nil {
		return *m.Instances
	}
	return 0
}

func (m *DesiredLRPUpdate) GetAnnotation() string {
	if m != nil && m.Annotation != nil {
		return *m.Annotation
	}
	return ""
}

type DesiredLRPKey struct {
	ProcessGuid string `protobuf:"bytes,1,opt,name=process_guid,json=processGuid" json:"process_guid"`
	Domain      string `protobuf:"bytes,2,opt,name=domain" json:"domain"`
	LogGuid     string `protobuf:"bytes,3,opt,name=log_guid,json=logGuid" json:"log_guid"`
}

func (m *DesiredLRPKey) Reset()                    { *m = DesiredLRPKey{} }
func (*DesiredLRPKey) ProtoMessage()               {}
func (*DesiredLRPKey) Descriptor() ([]byte, []int) { return fileDescriptorDesiredLrp, []int{4} }

func (m *DesiredLRPKey) GetProcessGuid() string {
	if m != nil {
		return m.ProcessGuid
	}
	return ""
}

func (m *DesiredLRPKey) GetDomain() string {
	if m != nil {
		return m.Domain
	}
	return ""
}

func (m *DesiredLRPKey) GetLogGuid() string {
	if m != nil {
		return m.LogGuid
	}
	return ""
}

type DesiredLRPResource struct {
	MemoryMb int32  `protobuf:"varint,1,opt,name=memory_mb,json=memoryMb" json:"memory_mb"`
	DiskMb   int32  `protobuf:"varint,2,opt,name=disk_mb,json=diskMb" json:"disk_mb"`
	RootFs   string `protobuf:"bytes,3,opt,name=root_fs,json=rootFs" json:"rootfs"`
	MaxPids  int32  `protobuf:"varint,4,opt,name=max_pids,json=maxPids" json:"max_pids"`
}

func (m *DesiredLRPResource) Reset()                    { *m = DesiredLRPResource{} }
func (*DesiredLRPResource) ProtoMessage()               {}
func (*DesiredLRPResource) Descriptor() ([]byte, []int) { return fileDescriptorDesiredLrp, []int{5} }

func (m *DesiredLRPResource) GetMemoryMb() int32 {
	if m != nil {
		return m.MemoryMb
	}
	return 0
}

func (m *DesiredLRPResource) GetDiskMb() int32 {
	if m != nil {
		return m.DiskMb
	}
	return 0
}

func (m *DesiredLRPResource) GetRootFs() string {
	if m != nil {
		return m.RootFs
	}
	return ""
}

func (m *DesiredLRPResource) GetMaxPids() int32 {
	if m != nil {
		return m.MaxPids
	}
	return 0
}

type DesiredLRP struct {
	ProcessGuid                   string                 `protobuf:"bytes,1,opt,name=process_guid,json=processGuid" json:"process_guid"`
	Domain                        string                 `protobuf:"bytes,2,opt,name=domain" json:"domain"`
	RootFs                        string                 `protobuf:"bytes,3,opt,name=root_fs,json=rootFs" json:"rootfs"`
	Instances                     int32                  `protobuf:"varint,4,opt,name=instances" json:"instances"`
	EnvironmentVariables          []*EnvironmentVariable `protobuf:"bytes,5,rep,name=environment_variables,json=environmentVariables" json:"env"`
	Setup                         *Action                `protobuf:"bytes,6,opt,name=setup" json:"setup,omitempty"`
	Action                        *Action                `protobuf:"bytes,7,opt,name=action" json:"action,omitempty"`
	StartTimeoutMs                int64                  `protobuf:"varint,27,opt,name=start_timeout_ms,json=startTimeoutMs" json:"start_timeout_ms"`
	DeprecatedStartTimeoutS       uint32                 `protobuf:"varint,8,opt,name=deprecated_start_timeout_s,json=deprecatedStartTimeoutS" json:"deprecated_timeout_ns,omitempty"`
	Monitor                       *Action                `protobuf:"bytes,9,opt,name=monitor" json:"monitor,omitempty"`
	DiskMb                        int32                  `protobuf:"varint,10,opt,name=disk_mb,json=diskMb" json:"disk_mb"`
	MemoryMb                      int32                  `protobuf:"varint,11,opt,name=memory_mb,json=memoryMb" json:"memory_mb"`
	CpuWeight                     uint32                 `protobuf:"varint,12,opt,name=cpu_weight,json=cpuWeight" json:"cpu_weight"`
	Privileged                    bool                   `protobuf:"varint,13,opt,name=privileged" json:"privileged"`
	Ports                         []uint32               `protobuf:"varint,14,rep,name=ports" json:"ports,omitempty"`
	Routes                        *Routes                `protobuf:"bytes,15,opt,name=routes,customtype=Routes" json:"routes,omitempty"`
	LogSource                     string                 `protobuf:"bytes,16,opt,name=log_source,json=logSource" json:"log_source"`
	LogGuid                       string                 `protobuf:"bytes,17,opt,name=log_guid,json=logGuid" json:"log_guid"`
	MetricsGuid                   string                 `protobuf:"bytes,18,opt,name=metrics_guid,json=metricsGuid" json:"metrics_guid"`
	Annotation                    string                 `protobuf:"bytes,19,opt,name=annotation" json:"annotation"`
	EgressRules                   []*SecurityGroupRule   `protobuf:"bytes,20,rep,name=egress_rules,json=egressRules" json:"egress_rules,omitempty"`
	ModificationTag               *ModificationTag       `protobuf:"bytes,21,opt,name=modification_tag,json=modificationTag" json:"modification_tag,omitempty"`
	CachedDependencies            []*CachedDependency    `protobuf:"bytes,22,rep,name=cached_dependencies,json=cachedDependencies" json:"cached_dependencies,omitempty"`
	LegacyDownloadUser            string                 `protobuf:"bytes,23,opt,name=legacy_download_user,json=legacyDownloadUser" json:"legacy_download_user,omitempty"`
	TrustedSystemCertificatesPath string                 `protobuf:"bytes,24,opt,name=trusted_system_certificates_path,json=trustedSystemCertificatesPath" json:"trusted_system_certificates_path,omitempty"`
	VolumeMounts                  []*VolumeMount         `protobuf:"bytes,25,rep,name=volume_mounts,json=volumeMounts" json:"volume_mounts,omitempty"`
	Network                       *Network               `protobuf:"bytes,26,opt,name=network" json:"network,omitempty"`
	PlacementTags                 []string               `protobuf:"bytes,28,rep,name=PlacementTags" json:"placement_tags,omitempty"`
	MaxPids                       int32                  `protobuf:"varint,29,opt,name=max_pids,json=maxPids" json:"max_pids"`
	CertificateProperties         *CertificateProperties `protobuf:"bytes,30,opt,name=certificate_properties,json=certificateProperties" json:"certificate_properties,omitempty"`
	ImageUsername                 string                 `protobuf:"bytes,31,opt,name=image_username,json=imageUsername" json:"image_username,omitempty"`
	ImagePassword                 string                 `protobuf:"bytes,32,opt,name=image_password,json=imagePassword" json:"image_password,omitempty"`
	CheckDefinition               *CheckDefinition       `protobuf:"bytes,33,opt,name=check_definition,json=checkDefinition" json:"check_definition,omitempty"`
}

func (m *DesiredLRP) Reset()                    { *m = DesiredLRP{} }
func (*DesiredLRP) ProtoMessage()               {}
func (*DesiredLRP) Descriptor() ([]byte, []int) { return fileDescriptorDesiredLrp, []int{6} }

func (m *DesiredLRP) GetProcessGuid() string {
	if m != nil {
		return m.ProcessGuid
	}
	return ""
}

func (m *DesiredLRP) GetDomain() string {
	if m != nil {
		return m.Domain
	}
	return ""
}

func (m *DesiredLRP) GetRootFs() string {
	if m != nil {
		return m.RootFs
	}
	return ""
}

func (m *DesiredLRP) GetInstances() int32 {
	if m != nil {
		return m.Instances
	}
	return 0
}

func (m *DesiredLRP) GetEnvironmentVariables() []*EnvironmentVariable {
	if m != nil {
		return m.EnvironmentVariables
	}
	return nil
}

func (m *DesiredLRP) GetSetup() *Action {
	if m != nil {
		return m.Setup
	}
	return nil
}

func (m *DesiredLRP) GetAction() *Action {
	if m != nil {
		return m.Action
	}
	return nil
}

func (m *DesiredLRP) GetStartTimeoutMs() int64 {
	if m != nil {
		return m.StartTimeoutMs
	}
	return 0
}

func (m *DesiredLRP) GetDeprecatedStartTimeoutS() uint32 {
	if m != nil {
		return m.DeprecatedStartTimeoutS
	}
	return 0
}

func (m *DesiredLRP) GetMonitor() *Action {
	if m != nil {
		return m.Monitor
	}
	return nil
}

func (m *DesiredLRP) GetDiskMb() int32 {
	if m != nil {
		return m.DiskMb
	}
	return 0
}

func (m *DesiredLRP) GetMemoryMb() int32 {
	if m != nil {
		return m.MemoryMb
	}
	return 0
}

func (m *DesiredLRP) GetCpuWeight() uint32 {
	if m != nil {
		return m.CpuWeight
	}
	return 0
}

func (m *DesiredLRP) GetPrivileged() bool {
	if m != nil {
		return m.Privileged
	}
	return false
}

func (m *DesiredLRP) GetPorts() []uint32 {
	if m != nil {
		return m.Ports
	}
	return nil
}

func (m *DesiredLRP) GetLogSource() string {
	if m != nil {
		return m.LogSource
	}
	return ""
}

func (m *DesiredLRP) GetLogGuid() string {
	if m != nil {
		return m.LogGuid
	}
	return ""
}

func (m *DesiredLRP) GetMetricsGuid() string {
	if m != nil {
		return m.MetricsGuid
	}
	return ""
}

func (m *DesiredLRP) GetAnnotation() string {
	if m != nil {
		return m.Annotation
	}
	return ""
}

func (m *DesiredLRP) GetEgressRules() []*SecurityGroupRule {
	if m != nil {
		return m.EgressRules
	}
	return nil
}

func (m *DesiredLRP) GetModificationTag() *ModificationTag {
	if m != nil {
		return m.ModificationTag
	}
	return nil
}

func (m *DesiredLRP) GetCachedDependencies() []*CachedDependency {
	if m != nil {
		return m.CachedDependencies
	}
	return nil
}

func (m *DesiredLRP) GetLegacyDownloadUser() string {
	if m != nil {
		return m.LegacyDownloadUser
	}
	return ""
}

func (m *DesiredLRP) GetTrustedSystemCertificatesPath() string {
	if m != nil {
		return m.TrustedSystemCertificatesPath
	}
	return ""
}

func (m *DesiredLRP) GetVolumeMounts() []*VolumeMount {
	if m != nil {
		return m.VolumeMounts
	}
	return nil
}

func (m *DesiredLRP) GetNetwork() *Network {
	if m != nil {
		return m.Network
	}
	return nil
}

func (m *DesiredLRP) GetPlacementTags() []string {
	if m != nil {
		return m.PlacementTags
	}
	return nil
}

func (m *DesiredLRP) GetMaxPids() int32 {
	if m != nil {
		return m.MaxPids
	}
	return 0
}

func (m *DesiredLRP) GetCertificateProperties() *CertificateProperties {
	if m != nil {
		return m.CertificateProperties
	}
	return nil
}

func (m *DesiredLRP) GetImageUsername() string {
	if m != nil {
		return m.ImageUsername
	}
	return ""
}

func (m *DesiredLRP) GetImagePassword() string {
	if m != nil {
		return m.ImagePassword
	}
	return ""
}

func (m *DesiredLRP) GetCheckDefinition() *CheckDefinition {
	if m != nil {
		return m.CheckDefinition
	}
	return nil
}

func init() {
	proto.RegisterType((*DesiredLRPSchedulingInfo)(nil), "models.DesiredLRPSchedulingInfo")
	proto.RegisterType((*DesiredLRPRunInfo)(nil), "models.DesiredLRPRunInfo")
	proto.RegisterType((*ProtoRoutes)(nil), "models.ProtoRoutes")
	proto.RegisterType((*DesiredLRPUpdate)(nil), "models.DesiredLRPUpdate")
	proto.RegisterType((*DesiredLRPKey)(nil), "models.DesiredLRPKey")
	proto.RegisterType((*DesiredLRPResource)(nil), "models.DesiredLRPResource")
	proto.RegisterType((*DesiredLRP)(nil), "models.DesiredLRP")
}
func (this *DesiredLRPSchedulingInfo) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*DesiredLRPSchedulingInfo)
	if !ok {
		that2, ok := that.(DesiredLRPSchedulingInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.DesiredLRPKey.Equal(&that1.DesiredLRPKey) {
		return false
	}
	if this.Annotation != that1.Annotation {
		return false
	}
	if this.Instances != that1.Instances {
		return false
	}
	if !this.DesiredLRPResource.Equal(&that1.DesiredLRPResource) {
		return false
	}
	if !this.Routes.Equal(that1.Routes) {
		return false
	}
	if !this.ModificationTag.Equal(&that1.ModificationTag) {
		return false
	}
	if !this.VolumePlacement.Equal(that1.VolumePlacement) {
		return false
	}
	if len(this.PlacementTags) != len(that1.PlacementTags) {
		return false
	}
	for i := range this.PlacementTags {
		if this.PlacementTags[i] != that1.PlacementTags[i] {
			return false
		}
	}
	return true
}
func (this *DesiredLRPRunInfo) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*DesiredLRPRunInfo)
	if !ok {
		that2, ok := that.(DesiredLRPRunInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.DesiredLRPKey.Equal(&that1.DesiredLRPKey) {
		return false
	}
	if len(this.EnvironmentVariables) != len(that1.EnvironmentVariables) {
		return false
	}
	for i := range this.EnvironmentVariables {
		if !this.EnvironmentVariables[i].Equal(&that1.EnvironmentVariables[i]) {
			return false
		}
	}
	if !this.Setup.Equal(that1.Setup) {
		return false
	}
	if !this.Action.Equal(that1.Action) {
		return false
	}
	if !this.Monitor.Equal(that1.Monitor) {
		return false
	}
	if this.DeprecatedStartTimeoutS != that1.DeprecatedStartTimeoutS {
		return false
	}
	if this.Privileged != that1.Privileged {
		return false
	}
	if this.CpuWeight != that1.CpuWeight {
		return false
	}
	if len(this.Ports) != len(that1.Ports) {
		return false
	}
	for i := range this.Ports {
		if this.Ports[i] != that1.Ports[i] {
			return false
		}
	}
	if len(this.EgressRules) != len(that1.EgressRules) {
		return false
	}
	for i := range this.EgressRules {
		if !this.EgressRules[i].Equal(&that1.EgressRules[i]) {
			return false
		}
	}
	if this.LogSource != that1.LogSource {
		return false
	}
	if this.MetricsGuid != that1.MetricsGuid {
		return false
	}
	if this.CreatedAt != that1.CreatedAt {
		return false
	}
	if len(this.CachedDependencies) != len(that1.CachedDependencies) {
		return false
	}
	for i := range this.CachedDependencies {
		if !this.CachedDependencies[i].Equal(that1.CachedDependencies[i]) {
			return false
		}
	}
	if this.LegacyDownloadUser != that1.LegacyDownloadUser {
		return false
	}
	if this.TrustedSystemCertificatesPath != that1.TrustedSystemCertificatesPath {
		return false
	}
	if len(this.VolumeMounts) != len(that1.VolumeMounts) {
		return false
	}
	for i := range this.VolumeMounts {
		if !this.VolumeMounts[i].Equal(that1.VolumeMounts[i]) {
			return false
		}
	}
	if !this.Network.Equal(that1.Network) {
		return false
	}
	if this.StartTimeoutMs != that1.StartTimeoutMs {
		return false
	}
	if !this.CertificateProperties.Equal(that1.CertificateProperties) {
		return false
	}
	if this.ImageUsername != that1.ImageUsername {
		return false
	}
	if this.ImagePassword != that1.ImagePassword {
		return false
	}
	if !this.CheckDefinition.Equal(that1.CheckDefinition) {
		return false
	}
	return true
}
func (this *ProtoRoutes) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*ProtoRoutes)
	if !ok {
		that2, ok := that.(ProtoRoutes)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.Routes) != len(that1.Routes) {
		return false
	}
	for i := range this.Routes {
		if !bytes.Equal(this.Routes[i], that1.Routes[i]) {
			return false
		}
	}
	return true
}
func (this *DesiredLRPUpdate) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*DesiredLRPUpdate)
	if !ok {
		that2, ok := that.(DesiredLRPUpdate)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Instances != nil && that1.Instances != nil {
		if *this.Instances != *that1.Instances {
			return false
		}
	} else if this.Instances != nil {
		return false
	} else if that1.Instances != nil {
		return false
	}
	if that1.Routes == nil {
		if this.Routes != nil {
			return false
		}
	} else if !this.Routes.Equal(*that1.Routes) {
		return false
	}
	if this.Annotation != nil && that1.Annotation != nil {
		if *this.Annotation != *that1.Annotation {
			return false
		}
	} else if this.Annotation != nil {
		return false
	} else if that1.Annotation != nil {
		return false
	}
	return true
}
func (this *DesiredLRPKey) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*DesiredLRPKey)
	if !ok {
		that2, ok := that.(DesiredLRPKey)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.ProcessGuid != that1.ProcessGuid {
		return false
	}
	if this.Domain != that1.Domain {
		return false
	}
	if this.LogGuid != that1.LogGuid {
		return false
	}
	return true
}
func (this *DesiredLRPResource) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*DesiredLRPResource)
	if !ok {
		that2, ok := that.(DesiredLRPResource)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.MemoryMb != that1.MemoryMb {
		return false
	}
	if this.DiskMb != that1.DiskMb {
		return false
	}
	if this.RootFs != that1.RootFs {
		return false
	}
	if this.MaxPids != that1.MaxPids {
		return false
	}
	return true
}
func (this *DesiredLRP) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*DesiredLRP)
	if !ok {
		that2, ok := that.(DesiredLRP)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.ProcessGuid != that1.ProcessGuid {
		return false
	}
	if this.Domain != that1.Domain {
		return false
	}
	if this.RootFs != that1.RootFs {
		return false
	}
	if this.Instances != that1.Instances {
		return false
	}
	if len(this.EnvironmentVariables) != len(that1.EnvironmentVariables) {
		return false
	}
	for i := range this.EnvironmentVariables {
		if !this.EnvironmentVariables[i].Equal(that1.EnvironmentVariables[i]) {
			return false
		}
	}
	if !this.Setup.Equal(that1.Setup) {
		return false
	}
	if !this.Action.Equal(that1.Action) {
		return false
	}
	if this.StartTimeoutMs != that1.StartTimeoutMs {
		return false
	}
	if this.DeprecatedStartTimeoutS != that1.DeprecatedStartTimeoutS {
		return false
	}
	if !this.Monitor.Equal(that1.Monitor) {
		return false
	}
	if this.DiskMb != that1.DiskMb {
		return false
	}
	if this.MemoryMb != that1.MemoryMb {
		return false
	}
	if this.CpuWeight != that1.CpuWeight {
		return false
	}
	if this.Privileged != that1.Privileged {
		return false
	}
	if len(this.Ports) != len(that1.Ports) {
		return false
	}
	for i := range this.Ports {
		if this.Ports[i] != that1.Ports[i] {
			return false
		}
	}
	if that1.Routes == nil {
		if this.Routes != nil {
			return false
		}
	} else if !this.Routes.Equal(*that1.Routes) {
		return false
	}
	if this.LogSource != that1.LogSource {
		return false
	}
	if this.LogGuid != that1.LogGuid {
		return false
	}
	if this.MetricsGuid != that1.MetricsGuid {
		return false
	}
	if this.Annotation != that1.Annotation {
		return false
	}
	if len(this.EgressRules) != len(that1.EgressRules) {
		return false
	}
	for i := range this.EgressRules {
		if !this.EgressRules[i].Equal(that1.EgressRules[i]) {
			return false
		}
	}
	if !this.ModificationTag.Equal(that1.ModificationTag) {
		return false
	}
	if len(this.CachedDependencies) != len(that1.CachedDependencies) {
		return false
	}
	for i := range this.CachedDependencies {
		if !this.CachedDependencies[i].Equal(that1.CachedDependencies[i]) {
			return false
		}
	}
	if this.LegacyDownloadUser != that1.LegacyDownloadUser {
		return false
	}
	if this.TrustedSystemCertificatesPath != that1.TrustedSystemCertificatesPath {
		return false
	}
	if len(this.VolumeMounts) != len(that1.VolumeMounts) {
		return false
	}
	for i := range this.VolumeMounts {
		if !this.VolumeMounts[i].Equal(that1.VolumeMounts[i]) {
			return false
		}
	}
	if !this.Network.Equal(that1.Network) {
		return false
	}
	if len(this.PlacementTags) != len(that1.PlacementTags) {
		return false
	}
	for i := range this.PlacementTags {
		if this.PlacementTags[i] != that1.PlacementTags[i] {
			return false
		}
	}
	if this.MaxPids != that1.MaxPids {
		return false
	}
	if !this.CertificateProperties.Equal(that1.CertificateProperties) {
		return false
	}
	if this.ImageUsername != that1.ImageUsername {
		return false
	}
	if this.ImagePassword != that1.ImagePassword {
		return false
	}
	if !this.CheckDefinition.Equal(that1.CheckDefinition) {
		return false
	}
	return true
}
func (this *DesiredLRPSchedulingInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 12)
	s = append(s, "&models.DesiredLRPSchedulingInfo{")
	s = append(s, "DesiredLRPKey: "+strings.Replace(this.DesiredLRPKey.GoString(), `&`, ``, 1)+",\n")
	s = append(s, "Annotation: "+fmt.Sprintf("%#v", this.Annotation)+",\n")
	s = append(s, "Instances: "+fmt.Sprintf("%#v", this.Instances)+",\n")
	s = append(s, "DesiredLRPResource: "+strings.Replace(this.DesiredLRPResource.GoString(), `&`, ``, 1)+",\n")
	s = append(s, "Routes: "+fmt.Sprintf("%#v", this.Routes)+",\n")
	s = append(s, "ModificationTag: "+strings.Replace(this.ModificationTag.GoString(), `&`, ``, 1)+",\n")
	if this.VolumePlacement != nil {
		s = append(s, "VolumePlacement: "+fmt.Sprintf("%#v", this.VolumePlacement)+",\n")
	}
	if this.PlacementTags != nil {
		s = append(s, "PlacementTags: "+fmt.Sprintf("%#v", this.PlacementTags)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DesiredLRPRunInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 27)
	s = append(s, "&models.DesiredLRPRunInfo{")
	s = append(s, "DesiredLRPKey: "+strings.Replace(this.DesiredLRPKey.GoString(), `&`, ``, 1)+",\n")
	if this.EnvironmentVariables != nil {
		s = append(s, "EnvironmentVariables: "+fmt.Sprintf("%#v", this.EnvironmentVariables)+",\n")
	}
	if this.Setup != nil {
		s = append(s, "Setup: "+fmt.Sprintf("%#v", this.Setup)+",\n")
	}
	if this.Action != nil {
		s = append(s, "Action: "+fmt.Sprintf("%#v", this.Action)+",\n")
	}
	if this.Monitor != nil {
		s = append(s, "Monitor: "+fmt.Sprintf("%#v", this.Monitor)+",\n")
	}
	s = append(s, "DeprecatedStartTimeoutS: "+fmt.Sprintf("%#v", this.DeprecatedStartTimeoutS)+",\n")
	s = append(s, "Privileged: "+fmt.Sprintf("%#v", this.Privileged)+",\n")
	s = append(s, "CpuWeight: "+fmt.Sprintf("%#v", this.CpuWeight)+",\n")
	if this.Ports != nil {
		s = append(s, "Ports: "+fmt.Sprintf("%#v", this.Ports)+",\n")
	}
	if this.EgressRules != nil {
		s = append(s, "EgressRules: "+fmt.Sprintf("%#v", this.EgressRules)+",\n")
	}
	s = append(s, "LogSource: "+fmt.Sprintf("%#v", this.LogSource)+",\n")
	s = append(s, "MetricsGuid: "+fmt.Sprintf("%#v", this.MetricsGuid)+",\n")
	s = append(s, "CreatedAt: "+fmt.Sprintf("%#v", this.CreatedAt)+",\n")
	if this.CachedDependencies != nil {
		s = append(s, "CachedDependencies: "+fmt.Sprintf("%#v", this.CachedDependencies)+",\n")
	}
	s = append(s, "LegacyDownloadUser: "+fmt.Sprintf("%#v", this.LegacyDownloadUser)+",\n")
	s = append(s, "TrustedSystemCertificatesPath: "+fmt.Sprintf("%#v", this.TrustedSystemCertificatesPath)+",\n")
	if this.VolumeMounts != nil {
		s = append(s, "VolumeMounts: "+fmt.Sprintf("%#v", this.VolumeMounts)+",\n")
	}
	if this.Network != nil {
		s = append(s, "Network: "+fmt.Sprintf("%#v", this.Network)+",\n")
	}
	s = append(s, "StartTimeoutMs: "+fmt.Sprintf("%#v", this.StartTimeoutMs)+",\n")
	if this.CertificateProperties != nil {
		s = append(s, "CertificateProperties: "+fmt.Sprintf("%#v", this.CertificateProperties)+",\n")
	}
	s = append(s, "ImageUsername: "+fmt.Sprintf("%#v", this.ImageUsername)+",\n")
	s = append(s, "ImagePassword: "+fmt.Sprintf("%#v", this.ImagePassword)+",\n")
	if this.CheckDefinition != nil {
		s = append(s, "CheckDefinition: "+fmt.Sprintf("%#v", this.CheckDefinition)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ProtoRoutes) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&models.ProtoRoutes{")
	keysForRoutes := make([]string, 0, len(this.Routes))
	for k, _ := range this.Routes {
		keysForRoutes = append(keysForRoutes, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForRoutes)
	mapStringForRoutes := "map[string][]byte{"
	for _, k := range keysForRoutes {
		mapStringForRoutes += fmt.Sprintf("%#v: %#v,", k, this.Routes[k])
	}
	mapStringForRoutes += "}"
	if this.Routes != nil {
		s = append(s, "Routes: "+mapStringForRoutes+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DesiredLRPUpdate) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&models.DesiredLRPUpdate{")
	if this.Instances != nil {
		s = append(s, "Instances: "+valueToGoStringDesiredLrp(this.Instances, "int32")+",\n")
	}
	if this.Routes != nil {
		s = append(s, "Routes: "+valueToGoStringDesiredLrp(this.Routes, "Routes")+",\n")
	}
	if this.Annotation != nil {
		s = append(s, "Annotation: "+valueToGoStringDesiredLrp(this.Annotation, "string")+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DesiredLRPKey) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&models.DesiredLRPKey{")
	s = append(s, "ProcessGuid: "+fmt.Sprintf("%#v", this.ProcessGuid)+",\n")
	s = append(s, "Domain: "+fmt.Sprintf("%#v", this.Domain)+",\n")
	s = append(s, "LogGuid: "+fmt.Sprintf("%#v", this.LogGuid)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DesiredLRPResource) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&models.DesiredLRPResource{")
	s = append(s, "MemoryMb: "+fmt.Sprintf("%#v", this.MemoryMb)+",\n")
	s = append(s, "DiskMb: "+fmt.Sprintf("%#v", this.DiskMb)+",\n")
	s = append(s, "RootFs: "+fmt.Sprintf("%#v", this.RootFs)+",\n")
	s = append(s, "MaxPids: "+fmt.Sprintf("%#v", this.MaxPids)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DesiredLRP) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 37)
	s = append(s, "&models.DesiredLRP{")
	s = append(s, "ProcessGuid: "+fmt.Sprintf("%#v", this.ProcessGuid)+",\n")
	s = append(s, "Domain: "+fmt.Sprintf("%#v", this.Domain)+",\n")
	s = append(s, "RootFs: "+fmt.Sprintf("%#v", this.RootFs)+",\n")
	s = append(s, "Instances: "+fmt.Sprintf("%#v", this.Instances)+",\n")
	if this.EnvironmentVariables != nil {
		s = append(s, "EnvironmentVariables: "+fmt.Sprintf("%#v", this.EnvironmentVariables)+",\n")
	}
	if this.Setup != nil {
		s = append(s, "Setup: "+fmt.Sprintf("%#v", this.Setup)+",\n")
	}
	if this.Action != nil {
		s = append(s, "Action: "+fmt.Sprintf("%#v", this.Action)+",\n")
	}
	s = append(s, "StartTimeoutMs: "+fmt.Sprintf("%#v", this.StartTimeoutMs)+",\n")
	s = append(s, "DeprecatedStartTimeoutS: "+fmt.Sprintf("%#v", this.DeprecatedStartTimeoutS)+",\n")
	if this.Monitor != nil {
		s = append(s, "Monitor: "+fmt.Sprintf("%#v", this.Monitor)+",\n")
	}
	s = append(s, "DiskMb: "+fmt.Sprintf("%#v", this.DiskMb)+",\n")
	s = append(s, "MemoryMb: "+fmt.Sprintf("%#v", this.MemoryMb)+",\n")
	s = append(s, "CpuWeight: "+fmt.Sprintf("%#v", this.CpuWeight)+",\n")
	s = append(s, "Privileged: "+fmt.Sprintf("%#v", this.Privileged)+",\n")
	if this.Ports != nil {
		s = append(s, "Ports: "+fmt.Sprintf("%#v", this.Ports)+",\n")
	}
	if this.Routes != nil {
		s = append(s, "Routes: "+valueToGoStringDesiredLrp(this.Routes, "Routes")+",\n")
	}
	s = append(s, "LogSource: "+fmt.Sprintf("%#v", this.LogSource)+",\n")
	s = append(s, "LogGuid: "+fmt.Sprintf("%#v", this.LogGuid)+",\n")
	s = append(s, "MetricsGuid: "+fmt.Sprintf("%#v", this.MetricsGuid)+",\n")
	s = append(s, "Annotation: "+fmt.Sprintf("%#v", this.Annotation)+",\n")
	if this.EgressRules != nil {
		s = append(s, "EgressRules: "+fmt.Sprintf("%#v", this.EgressRules)+",\n")
	}
	if this.ModificationTag != nil {
		s = append(s, "ModificationTag: "+fmt.Sprintf("%#v", this.ModificationTag)+",\n")
	}
	if this.CachedDependencies != nil {
		s = append(s, "CachedDependencies: "+fmt.Sprintf("%#v", this.CachedDependencies)+",\n")
	}
	s = append(s, "LegacyDownloadUser: "+fmt.Sprintf("%#v", this.LegacyDownloadUser)+",\n")
	s = append(s, "TrustedSystemCertificatesPath: "+fmt.Sprintf("%#v", this.TrustedSystemCertificatesPath)+",\n")
	if this.VolumeMounts != nil {
		s = append(s, "VolumeMounts: "+fmt.Sprintf("%#v", this.VolumeMounts)+",\n")
	}
	if this.Network != nil {
		s = append(s, "Network: "+fmt.Sprintf("%#v", this.Network)+",\n")
	}
	if this.PlacementTags != nil {
		s = append(s, "PlacementTags: "+fmt.Sprintf("%#v", this.PlacementTags)+",\n")
	}
	s = append(s, "MaxPids: "+fmt.Sprintf("%#v", this.MaxPids)+",\n")
	if this.CertificateProperties != nil {
		s = append(s, "CertificateProperties: "+fmt.Sprintf("%#v", this.CertificateProperties)+",\n")
	}
	s = append(s, "ImageUsername: "+fmt.Sprintf("%#v", this.ImageUsername)+",\n")
	s = append(s, "ImagePassword: "+fmt.Sprintf("%#v", this.ImagePassword)+",\n")
	if this.CheckDefinition != nil {
		s = append(s, "CheckDefinition: "+fmt.Sprintf("%#v", this.CheckDefinition)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringDesiredLrp(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *DesiredLRPSchedulingInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DesiredLRPSchedulingInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintDesiredLrp(dAtA, i, uint64(m.DesiredLRPKey.Size()))
	n1, err := m.DesiredLRPKey.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n1
	dAtA[i] = 0x12
	i++
	i = encodeVarintDesiredLrp(dAtA, i, uint64(len(m.Annotation)))
	i += copy(dAtA[i:], m.Annotation)
	dAtA[i] = 0x18
	i++
	i = encodeVarintDesiredLrp(dAtA, i, uint64(m.Instances))
	dAtA[i] = 0x22
	i++
	i = encodeVarintDesiredLrp(dAtA, i, uint64(m.DesiredLRPResource.Size()))
	n2, err := m.DesiredLRPResource.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n2
	dAtA[i] = 0x2a
	i++
	i = encodeVarintDesiredLrp(dAtA, i, uint64(m.Routes.Size()))
	n3, err := m.Routes.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n3
	dAtA[i] = 0x32
	i++
	i = encodeVarintDesiredLrp(dAtA, i, uint64(m.ModificationTag.Size()))
	n4, err := m.ModificationTag.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n4
	if m.VolumePlacement != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintDesiredLrp(dAtA, i, uint64(m.VolumePlacement.Size()))
		n5, err := m.VolumePlacement.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if len(m.PlacementTags) > 0 {
		for _, s := range m.PlacementTags {
			dAtA[i] = 0x42
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *DesiredLRPRunInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DesiredLRPRunInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintDesiredLrp(dAtA, i, uint64(m.DesiredLRPKey.Size()))
	n6, err := m.DesiredLRPKey.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n6
	if len(m.EnvironmentVariables) > 0 {
		for _, msg := range m.EnvironmentVariables {
			dAtA[i] = 0x12
			i++
			i = encodeVarintDesiredLrp(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Setup != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintDesiredLrp(dAtA, i, uint64(m.Setup.Size()))
		n7, err := m.Setup.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if m.Action != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintDesiredLrp(dAtA, i, uint64(m.Action.Size()))
		n8, err := m.Action.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.Monitor != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintDesiredLrp(dAtA, i, uint64(m.Monitor.Size()))
		n9, err := m.Monitor.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	dAtA[i] = 0x30
	i++
	i = encodeVarintDesiredLrp(dAtA, i, uint64(m.DeprecatedStartTimeoutS))
	dAtA[i] = 0x38
	i++
	if m.Privileged {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x40
	i++
	i = encodeVarintDesiredLrp(dAtA, i, uint64(m.CpuWeight))
	if len(m.Ports) > 0 {
		for _, num := range m.Ports {
			dAtA[i] = 0x48
			i++
			i = encodeVarintDesiredLrp(dAtA, i, uint64(num))
		}
	}
	if len(m.EgressRules) > 0 {
		for _, msg := range m.EgressRules {
			dAtA[i] = 0x52
			i++
			i = encodeVarintDesiredLrp(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	dAtA[i] = 0x5a
	i++
	i = encodeVarintDesiredLrp(dAtA, i, uint64(len(m.LogSource)))
	i += copy(dAtA[i:], m.LogSource)
	dAtA[i] = 0x62
	i++
	i = encodeVarintDesiredLrp(dAtA, i, uint64(len(m.MetricsGuid)))
	i += copy(dAtA[i:], m.MetricsGuid)
	dAtA[i] = 0x68
	i++
	i = encodeVarintDesiredLrp(dAtA, i, uint64(m.CreatedAt))
	if len(m.CachedDependencies) > 0 {
		for _, msg := range m.CachedDependencies {
			dAtA[i] = 0x72
			i++
			i = encodeVarintDesiredLrp(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	dAtA[i] = 0x7a
	i++
	i = encodeVarintDesiredLrp(dAtA, i, uint64(len(m.LegacyDownloadUser)))
	i += copy(dAtA[i:], m.LegacyDownloadUser)
	dAtA[i] = 0x82
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintDesiredLrp(dAtA, i, uint64(len(m.TrustedSystemCertificatesPath)))
	i += copy(dAtA[i:], m.TrustedSystemCertificatesPath)
	if len(m.VolumeMounts) > 0 {
		for _, msg := range m.VolumeMounts {
			dAtA[i] = 0x8a
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintDesiredLrp(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Network != nil {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintDesiredLrp(dAtA, i, uint64(m.Network.Size()))
		n10, err := m.Network.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	dAtA[i] = 0x98
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintDesiredLrp(dAtA, i, uint64(m.StartTimeoutMs))
	if m.CertificateProperties != nil {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintDesiredLrp(dAtA, i, uint64(m.CertificateProperties.Size()))
		n11, err := m.CertificateProperties.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	dAtA[i] = 0xaa
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintDesiredLrp(dAtA, i, uint64(len(m.ImageUsername)))
	i += copy(dAtA[i:], m.ImageUsername)
	dAtA[i] = 0xb2
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintDesiredLrp(dAtA, i, uint64(len(m.ImagePassword)))
	i += copy(dAtA[i:], m.ImagePassword)
	if m.CheckDefinition != nil {
		dAtA[i] = 0xba
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintDesiredLrp(dAtA, i, uint64(m.CheckDefinition.Size()))
		n12, err := m.CheckDefinition.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	return i, nil
}

func (m *ProtoRoutes) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProtoRoutes) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Routes) > 0 {
		for k, _ := range m.Routes {
			dAtA[i] = 0xa
			i++
			v := m.Routes[k]
			byteSize := 0
			if v != nil {
				byteSize = 1 + len(v) + sovDesiredLrp(uint64(len(v)))
			}
			mapSize := 1 + len(k) + sovDesiredLrp(uint64(len(k))) + byteSize
			i = encodeVarintDesiredLrp(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintDesiredLrp(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintDesiredLrp(dAtA, i, uint64(len(v)))
				i += copy(dAtA[i:], v)
			}
		}
	}
	return i, nil
}

func (m *DesiredLRPUpdate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DesiredLRPUpdate) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Instances != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintDesiredLrp(dAtA, i, uint64(*m.Instances))
	}
	if m.Routes != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDesiredLrp(dAtA, i, uint64(m.Routes.Size()))
		n13, err := m.Routes.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	if m.Annotation != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintDesiredLrp(dAtA, i, uint64(len(*m.Annotation)))
		i += copy(dAtA[i:], *m.Annotation)
	}
	return i, nil
}

func (m *DesiredLRPKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DesiredLRPKey) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintDesiredLrp(dAtA, i, uint64(len(m.ProcessGuid)))
	i += copy(dAtA[i:], m.ProcessGuid)
	dAtA[i] = 0x12
	i++
	i = encodeVarintDesiredLrp(dAtA, i, uint64(len(m.Domain)))
	i += copy(dAtA[i:], m.Domain)
	dAtA[i] = 0x1a
	i++
	i = encodeVarintDesiredLrp(dAtA, i, uint64(len(m.LogGuid)))
	i += copy(dAtA[i:], m.LogGuid)
	return i, nil
}

func (m *DesiredLRPResource) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DesiredLRPResource) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintDesiredLrp(dAtA, i, uint64(m.MemoryMb))
	dAtA[i] = 0x10
	i++
	i = encodeVarintDesiredLrp(dAtA, i, uint64(m.DiskMb))
	dAtA[i] = 0x1a
	i++
	i = encodeVarintDesiredLrp(dAtA, i, uint64(len(m.RootFs)))
	i += copy(dAtA[i:], m.RootFs)
	dAtA[i] = 0x20
	i++
	i = encodeVarintDesiredLrp(dAtA, i, uint64(m.MaxPids))
	return i, nil
}

func (m *DesiredLRP) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DesiredLRP) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintDesiredLrp(dAtA, i, uint64(len(m.ProcessGuid)))
	i += copy(dAtA[i:], m.ProcessGuid)
	dAtA[i] = 0x12
	i++
	i = encodeVarintDesiredLrp(dAtA, i, uint64(len(m.Domain)))
	i += copy(dAtA[i:], m.Domain)
	dAtA[i] = 0x1a
	i++
	i = encodeVarintDesiredLrp(dAtA, i, uint64(len(m.RootFs)))
	i += copy(dAtA[i:], m.RootFs)
	dAtA[i] = 0x20
	i++
	i = encodeVarintDesiredLrp(dAtA, i, uint64(m.Instances))
	if len(m.EnvironmentVariables) > 0 {
		for _, msg := range m.EnvironmentVariables {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintDesiredLrp(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Setup != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintDesiredLrp(dAtA, i, uint64(m.Setup.Size()))
		n14, err := m.Setup.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	if m.Action != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintDesiredLrp(dAtA, i, uint64(m.Action.Size()))
		n15, err := m.Action.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	dAtA[i] = 0x40
	i++
	i = encodeVarintDesiredLrp(dAtA, i, uint64(m.DeprecatedStartTimeoutS))
	if m.Monitor != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintDesiredLrp(dAtA, i, uint64(m.Monitor.Size()))
		n16, err := m.Monitor.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	dAtA[i] = 0x50
	i++
	i = encodeVarintDesiredLrp(dAtA, i, uint64(m.DiskMb))
	dAtA[i] = 0x58
	i++
	i = encodeVarintDesiredLrp(dAtA, i, uint64(m.MemoryMb))
	dAtA[i] = 0x60
	i++
	i = encodeVarintDesiredLrp(dAtA, i, uint64(m.CpuWeight))
	dAtA[i] = 0x68
	i++
	if m.Privileged {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	if len(m.Ports) > 0 {
		for _, num := range m.Ports {
			dAtA[i] = 0x70
			i++
			i = encodeVarintDesiredLrp(dAtA, i, uint64(num))
		}
	}
	if m.Routes != nil {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintDesiredLrp(dAtA, i, uint64(m.Routes.Size()))
		n17, err := m.Routes.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	dAtA[i] = 0x82
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintDesiredLrp(dAtA, i, uint64(len(m.LogSource)))
	i += copy(dAtA[i:], m.LogSource)
	dAtA[i] = 0x8a
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintDesiredLrp(dAtA, i, uint64(len(m.LogGuid)))
	i += copy(dAtA[i:], m.LogGuid)
	dAtA[i] = 0x92
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintDesiredLrp(dAtA, i, uint64(len(m.MetricsGuid)))
	i += copy(dAtA[i:], m.MetricsGuid)
	dAtA[i] = 0x9a
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintDesiredLrp(dAtA, i, uint64(len(m.Annotation)))
	i += copy(dAtA[i:], m.Annotation)
	if len(m.EgressRules) > 0 {
		for _, msg := range m.EgressRules {
			dAtA[i] = 0xa2
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintDesiredLrp(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.ModificationTag != nil {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintDesiredLrp(dAtA, i, uint64(m.ModificationTag.Size()))
		n18, err := m.ModificationTag.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	if len(m.CachedDependencies) > 0 {
		for _, msg := range m.CachedDependencies {
			dAtA[i] = 0xb2
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintDesiredLrp(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	dAtA[i] = 0xba
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintDesiredLrp(dAtA, i, uint64(len(m.LegacyDownloadUser)))
	i += copy(dAtA[i:], m.LegacyDownloadUser)
	dAtA[i] = 0xc2
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintDesiredLrp(dAtA, i, uint64(len(m.TrustedSystemCertificatesPath)))
	i += copy(dAtA[i:], m.TrustedSystemCertificatesPath)
	if len(m.VolumeMounts) > 0 {
		for _, msg := range m.VolumeMounts {
			dAtA[i] = 0xca
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintDesiredLrp(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Network != nil {
		dAtA[i] = 0xd2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintDesiredLrp(dAtA, i, uint64(m.Network.Size()))
		n19, err := m.Network.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	dAtA[i] = 0xd8
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintDesiredLrp(dAtA, i, uint64(m.StartTimeoutMs))
	if len(m.PlacementTags) > 0 {
		for _, s := range m.PlacementTags {
			dAtA[i] = 0xe2
			i++
			dAtA[i] = 0x1
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	dAtA[i] = 0xe8
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintDesiredLrp(dAtA, i, uint64(m.MaxPids))
	if m.CertificateProperties != nil {
		dAtA[i] = 0xf2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintDesiredLrp(dAtA, i, uint64(m.CertificateProperties.Size()))
		n20, err := m.CertificateProperties.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	dAtA[i] = 0xfa
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintDesiredLrp(dAtA, i, uint64(len(m.ImageUsername)))
	i += copy(dAtA[i:], m.ImageUsername)
	dAtA[i] = 0x82
	i++
	dAtA[i] = 0x2
	i++
	i = encodeVarintDesiredLrp(dAtA, i, uint64(len(m.ImagePassword)))
	i += copy(dAtA[i:], m.ImagePassword)
	if m.CheckDefinition != nil {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintDesiredLrp(dAtA, i, uint64(m.CheckDefinition.Size()))
		n21, err := m.CheckDefinition.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	return i, nil
}

func encodeFixed64DesiredLrp(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32DesiredLrp(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintDesiredLrp(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *DesiredLRPSchedulingInfo) Size() (n int) {
	var l int
	_ = l
	l = m.DesiredLRPKey.Size()
	n += 1 + l + sovDesiredLrp(uint64(l))
	l = len(m.Annotation)
	n += 1 + l + sovDesiredLrp(uint64(l))
	n += 1 + sovDesiredLrp(uint64(m.Instances))
	l = m.DesiredLRPResource.Size()
	n += 1 + l + sovDesiredLrp(uint64(l))
	l = m.Routes.Size()
	n += 1 + l + sovDesiredLrp(uint64(l))
	l = m.ModificationTag.Size()
	n += 1 + l + sovDesiredLrp(uint64(l))
	if m.VolumePlacement != nil {
		l = m.VolumePlacement.Size()
		n += 1 + l + sovDesiredLrp(uint64(l))
	}
	if len(m.PlacementTags) > 0 {
		for _, s := range m.PlacementTags {
			l = len(s)
			n += 1 + l + sovDesiredLrp(uint64(l))
		}
	}
	return n
}

func (m *DesiredLRPRunInfo) Size() (n int) {
	var l int
	_ = l
	l = m.DesiredLRPKey.Size()
	n += 1 + l + sovDesiredLrp(uint64(l))
	if len(m.EnvironmentVariables) > 0 {
		for _, e := range m.EnvironmentVariables {
			l = e.Size()
			n += 1 + l + sovDesiredLrp(uint64(l))
		}
	}
	if m.Setup != nil {
		l = m.Setup.Size()
		n += 1 + l + sovDesiredLrp(uint64(l))
	}
	if m.Action != nil {
		l = m.Action.Size()
		n += 1 + l + sovDesiredLrp(uint64(l))
	}
	if m.Monitor != nil {
		l = m.Monitor.Size()
		n += 1 + l + sovDesiredLrp(uint64(l))
	}
	n += 1 + sovDesiredLrp(uint64(m.DeprecatedStartTimeoutS))
	n += 2
	n += 1 + sovDesiredLrp(uint64(m.CpuWeight))
	if len(m.Ports) > 0 {
		for _, e := range m.Ports {
			n += 1 + sovDesiredLrp(uint64(e))
		}
	}
	if len(m.EgressRules) > 0 {
		for _, e := range m.EgressRules {
			l = e.Size()
			n += 1 + l + sovDesiredLrp(uint64(l))
		}
	}
	l = len(m.LogSource)
	n += 1 + l + sovDesiredLrp(uint64(l))
	l = len(m.MetricsGuid)
	n += 1 + l + sovDesiredLrp(uint64(l))
	n += 1 + sovDesiredLrp(uint64(m.CreatedAt))
	if len(m.CachedDependencies) > 0 {
		for _, e := range m.CachedDependencies {
			l = e.Size()
			n += 1 + l + sovDesiredLrp(uint64(l))
		}
	}
	l = len(m.LegacyDownloadUser)
	n += 1 + l + sovDesiredLrp(uint64(l))
	l = len(m.TrustedSystemCertificatesPath)
	n += 2 + l + sovDesiredLrp(uint64(l))
	if len(m.VolumeMounts) > 0 {
		for _, e := range m.VolumeMounts {
			l = e.Size()
			n += 2 + l + sovDesiredLrp(uint64(l))
		}
	}
	if m.Network != nil {
		l = m.Network.Size()
		n += 2 + l + sovDesiredLrp(uint64(l))
	}
	n += 2 + sovDesiredLrp(uint64(m.StartTimeoutMs))
	if m.CertificateProperties != nil {
		l = m.CertificateProperties.Size()
		n += 2 + l + sovDesiredLrp(uint64(l))
	}
	l = len(m.ImageUsername)
	n += 2 + l + sovDesiredLrp(uint64(l))
	l = len(m.ImagePassword)
	n += 2 + l + sovDesiredLrp(uint64(l))
	if m.CheckDefinition != nil {
		l = m.CheckDefinition.Size()
		n += 2 + l + sovDesiredLrp(uint64(l))
	}
	return n
}

func (m *ProtoRoutes) Size() (n int) {
	var l int
	_ = l
	if len(m.Routes) > 0 {
		for k, v := range m.Routes {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = 1 + len(v) + sovDesiredLrp(uint64(len(v)))
			}
			mapEntrySize := 1 + len(k) + sovDesiredLrp(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovDesiredLrp(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *DesiredLRPUpdate) Size() (n int) {
	var l int
	_ = l
	if m.Instances != nil {
		n += 1 + sovDesiredLrp(uint64(*m.Instances))
	}
	if m.Routes != nil {
		l = m.Routes.Size()
		n += 1 + l + sovDesiredLrp(uint64(l))
	}
	if m.Annotation != nil {
		l = len(*m.Annotation)
		n += 1 + l + sovDesiredLrp(uint64(l))
	}
	return n
}

func (m *DesiredLRPKey) Size() (n int) {
	var l int
	_ = l
	l = len(m.ProcessGuid)
	n += 1 + l + sovDesiredLrp(uint64(l))
	l = len(m.Domain)
	n += 1 + l + sovDesiredLrp(uint64(l))
	l = len(m.LogGuid)
	n += 1 + l + sovDesiredLrp(uint64(l))
	return n
}

func (m *DesiredLRPResource) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovDesiredLrp(uint64(m.MemoryMb))
	n += 1 + sovDesiredLrp(uint64(m.DiskMb))
	l = len(m.RootFs)
	n += 1 + l + sovDesiredLrp(uint64(l))
	n += 1 + sovDesiredLrp(uint64(m.MaxPids))
	return n
}

func (m *DesiredLRP) Size() (n int) {
	var l int
	_ = l
	l = len(m.ProcessGuid)
	n += 1 + l + sovDesiredLrp(uint64(l))
	l = len(m.Domain)
	n += 1 + l + sovDesiredLrp(uint64(l))
	l = len(m.RootFs)
	n += 1 + l + sovDesiredLrp(uint64(l))
	n += 1 + sovDesiredLrp(uint64(m.Instances))
	if len(m.EnvironmentVariables) > 0 {
		for _, e := range m.EnvironmentVariables {
			l = e.Size()
			n += 1 + l + sovDesiredLrp(uint64(l))
		}
	}
	if m.Setup != nil {
		l = m.Setup.Size()
		n += 1 + l + sovDesiredLrp(uint64(l))
	}
	if m.Action != nil {
		l = m.Action.Size()
		n += 1 + l + sovDesiredLrp(uint64(l))
	}
	n += 1 + sovDesiredLrp(uint64(m.DeprecatedStartTimeoutS))
	if m.Monitor != nil {
		l = m.Monitor.Size()
		n += 1 + l + sovDesiredLrp(uint64(l))
	}
	n += 1 + sovDesiredLrp(uint64(m.DiskMb))
	n += 1 + sovDesiredLrp(uint64(m.MemoryMb))
	n += 1 + sovDesiredLrp(uint64(m.CpuWeight))
	n += 2
	if len(m.Ports) > 0 {
		for _, e := range m.Ports {
			n += 1 + sovDesiredLrp(uint64(e))
		}
	}
	if m.Routes != nil {
		l = m.Routes.Size()
		n += 1 + l + sovDesiredLrp(uint64(l))
	}
	l = len(m.LogSource)
	n += 2 + l + sovDesiredLrp(uint64(l))
	l = len(m.LogGuid)
	n += 2 + l + sovDesiredLrp(uint64(l))
	l = len(m.MetricsGuid)
	n += 2 + l + sovDesiredLrp(uint64(l))
	l = len(m.Annotation)
	n += 2 + l + sovDesiredLrp(uint64(l))
	if len(m.EgressRules) > 0 {
		for _, e := range m.EgressRules {
			l = e.Size()
			n += 2 + l + sovDesiredLrp(uint64(l))
		}
	}
	if m.ModificationTag != nil {
		l = m.ModificationTag.Size()
		n += 2 + l + sovDesiredLrp(uint64(l))
	}
	if len(m.CachedDependencies) > 0 {
		for _, e := range m.CachedDependencies {
			l = e.Size()
			n += 2 + l + sovDesiredLrp(uint64(l))
		}
	}
	l = len(m.LegacyDownloadUser)
	n += 2 + l + sovDesiredLrp(uint64(l))
	l = len(m.TrustedSystemCertificatesPath)
	n += 2 + l + sovDesiredLrp(uint64(l))
	if len(m.VolumeMounts) > 0 {
		for _, e := range m.VolumeMounts {
			l = e.Size()
			n += 2 + l + sovDesiredLrp(uint64(l))
		}
	}
	if m.Network != nil {
		l = m.Network.Size()
		n += 2 + l + sovDesiredLrp(uint64(l))
	}
	n += 2 + sovDesiredLrp(uint64(m.StartTimeoutMs))
	if len(m.PlacementTags) > 0 {
		for _, s := range m.PlacementTags {
			l = len(s)
			n += 2 + l + sovDesiredLrp(uint64(l))
		}
	}
	n += 2 + sovDesiredLrp(uint64(m.MaxPids))
	if m.CertificateProperties != nil {
		l = m.CertificateProperties.Size()
		n += 2 + l + sovDesiredLrp(uint64(l))
	}
	l = len(m.ImageUsername)
	n += 2 + l + sovDesiredLrp(uint64(l))
	l = len(m.ImagePassword)
	n += 2 + l + sovDesiredLrp(uint64(l))
	if m.CheckDefinition != nil {
		l = m.CheckDefinition.Size()
		n += 2 + l + sovDesiredLrp(uint64(l))
	}
	return n
}

func sovDesiredLrp(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozDesiredLrp(x uint64) (n int) {
	return sovDesiredLrp(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *DesiredLRPSchedulingInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DesiredLRPSchedulingInfo{`,
		`DesiredLRPKey:` + strings.Replace(strings.Replace(this.DesiredLRPKey.String(), "DesiredLRPKey", "DesiredLRPKey", 1), `&`, ``, 1) + `,`,
		`Annotation:` + fmt.Sprintf("%v", this.Annotation) + `,`,
		`Instances:` + fmt.Sprintf("%v", this.Instances) + `,`,
		`DesiredLRPResource:` + strings.Replace(strings.Replace(this.DesiredLRPResource.String(), "DesiredLRPResource", "DesiredLRPResource", 1), `&`, ``, 1) + `,`,
		`Routes:` + fmt.Sprintf("%v", this.Routes) + `,`,
		`ModificationTag:` + strings.Replace(strings.Replace(this.ModificationTag.String(), "ModificationTag", "ModificationTag", 1), `&`, ``, 1) + `,`,
		`VolumePlacement:` + strings.Replace(fmt.Sprintf("%v", this.VolumePlacement), "VolumePlacement", "VolumePlacement", 1) + `,`,
		`PlacementTags:` + fmt.Sprintf("%v", this.PlacementTags) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DesiredLRPRunInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DesiredLRPRunInfo{`,
		`DesiredLRPKey:` + strings.Replace(strings.Replace(this.DesiredLRPKey.String(), "DesiredLRPKey", "DesiredLRPKey", 1), `&`, ``, 1) + `,`,
		`EnvironmentVariables:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.EnvironmentVariables), "EnvironmentVariable", "EnvironmentVariable", 1), `&`, ``, 1) + `,`,
		`Setup:` + strings.Replace(fmt.Sprintf("%v", this.Setup), "Action", "Action", 1) + `,`,
		`Action:` + strings.Replace(fmt.Sprintf("%v", this.Action), "Action", "Action", 1) + `,`,
		`Monitor:` + strings.Replace(fmt.Sprintf("%v", this.Monitor), "Action", "Action", 1) + `,`,
		`DeprecatedStartTimeoutS:` + fmt.Sprintf("%v", this.DeprecatedStartTimeoutS) + `,`,
		`Privileged:` + fmt.Sprintf("%v", this.Privileged) + `,`,
		`CpuWeight:` + fmt.Sprintf("%v", this.CpuWeight) + `,`,
		`Ports:` + fmt.Sprintf("%v", this.Ports) + `,`,
		`EgressRules:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.EgressRules), "SecurityGroupRule", "SecurityGroupRule", 1), `&`, ``, 1) + `,`,
		`LogSource:` + fmt.Sprintf("%v", this.LogSource) + `,`,
		`MetricsGuid:` + fmt.Sprintf("%v", this.MetricsGuid) + `,`,
		`CreatedAt:` + fmt.Sprintf("%v", this.CreatedAt) + `,`,
		`CachedDependencies:` + strings.Replace(fmt.Sprintf("%v", this.CachedDependencies), "CachedDependency", "CachedDependency", 1) + `,`,
		`LegacyDownloadUser:` + fmt.Sprintf("%v", this.LegacyDownloadUser) + `,`,
		`TrustedSystemCertificatesPath:` + fmt.Sprintf("%v", this.TrustedSystemCertificatesPath) + `,`,
		`VolumeMounts:` + strings.Replace(fmt.Sprintf("%v", this.VolumeMounts), "VolumeMount", "VolumeMount", 1) + `,`,
		`Network:` + strings.Replace(fmt.Sprintf("%v", this.Network), "Network", "Network", 1) + `,`,
		`StartTimeoutMs:` + fmt.Sprintf("%v", this.StartTimeoutMs) + `,`,
		`CertificateProperties:` + strings.Replace(fmt.Sprintf("%v", this.CertificateProperties), "CertificateProperties", "CertificateProperties", 1) + `,`,
		`ImageUsername:` + fmt.Sprintf("%v", this.ImageUsername) + `,`,
		`ImagePassword:` + fmt.Sprintf("%v", this.ImagePassword) + `,`,
		`CheckDefinition:` + strings.Replace(fmt.Sprintf("%v", this.CheckDefinition), "CheckDefinition", "CheckDefinition", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ProtoRoutes) String() string {
	if this == nil {
		return "nil"
	}
	keysForRoutes := make([]string, 0, len(this.Routes))
	for k, _ := range this.Routes {
		keysForRoutes = append(keysForRoutes, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForRoutes)
	mapStringForRoutes := "map[string][]byte{"
	for _, k := range keysForRoutes {
		mapStringForRoutes += fmt.Sprintf("%v: %v,", k, this.Routes[k])
	}
	mapStringForRoutes += "}"
	s := strings.Join([]string{`&ProtoRoutes{`,
		`Routes:` + mapStringForRoutes + `,`,
		`}`,
	}, "")
	return s
}
func (this *DesiredLRPUpdate) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DesiredLRPUpdate{`,
		`Instances:` + valueToStringDesiredLrp(this.Instances) + `,`,
		`Routes:` + valueToStringDesiredLrp(this.Routes) + `,`,
		`Annotation:` + valueToStringDesiredLrp(this.Annotation) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DesiredLRPKey) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DesiredLRPKey{`,
		`ProcessGuid:` + fmt.Sprintf("%v", this.ProcessGuid) + `,`,
		`Domain:` + fmt.Sprintf("%v", this.Domain) + `,`,
		`LogGuid:` + fmt.Sprintf("%v", this.LogGuid) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DesiredLRPResource) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DesiredLRPResource{`,
		`MemoryMb:` + fmt.Sprintf("%v", this.MemoryMb) + `,`,
		`DiskMb:` + fmt.Sprintf("%v", this.DiskMb) + `,`,
		`RootFs:` + fmt.Sprintf("%v", this.RootFs) + `,`,
		`MaxPids:` + fmt.Sprintf("%v", this.MaxPids) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DesiredLRP) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DesiredLRP{`,
		`ProcessGuid:` + fmt.Sprintf("%v", this.ProcessGuid) + `,`,
		`Domain:` + fmt.Sprintf("%v", this.Domain) + `,`,
		`RootFs:` + fmt.Sprintf("%v", this.RootFs) + `,`,
		`Instances:` + fmt.Sprintf("%v", this.Instances) + `,`,
		`EnvironmentVariables:` + strings.Replace(fmt.Sprintf("%v", this.EnvironmentVariables), "EnvironmentVariable", "EnvironmentVariable", 1) + `,`,
		`Setup:` + strings.Replace(fmt.Sprintf("%v", this.Setup), "Action", "Action", 1) + `,`,
		`Action:` + strings.Replace(fmt.Sprintf("%v", this.Action), "Action", "Action", 1) + `,`,
		`DeprecatedStartTimeoutS:` + fmt.Sprintf("%v", this.DeprecatedStartTimeoutS) + `,`,
		`Monitor:` + strings.Replace(fmt.Sprintf("%v", this.Monitor), "Action", "Action", 1) + `,`,
		`DiskMb:` + fmt.Sprintf("%v", this.DiskMb) + `,`,
		`MemoryMb:` + fmt.Sprintf("%v", this.MemoryMb) + `,`,
		`CpuWeight:` + fmt.Sprintf("%v", this.CpuWeight) + `,`,
		`Privileged:` + fmt.Sprintf("%v", this.Privileged) + `,`,
		`Ports:` + fmt.Sprintf("%v", this.Ports) + `,`,
		`Routes:` + valueToStringDesiredLrp(this.Routes) + `,`,
		`LogSource:` + fmt.Sprintf("%v", this.LogSource) + `,`,
		`LogGuid:` + fmt.Sprintf("%v", this.LogGuid) + `,`,
		`MetricsGuid:` + fmt.Sprintf("%v", this.MetricsGuid) + `,`,
		`Annotation:` + fmt.Sprintf("%v", this.Annotation) + `,`,
		`EgressRules:` + strings.Replace(fmt.Sprintf("%v", this.EgressRules), "SecurityGroupRule", "SecurityGroupRule", 1) + `,`,
		`ModificationTag:` + strings.Replace(fmt.Sprintf("%v", this.ModificationTag), "ModificationTag", "ModificationTag", 1) + `,`,
		`CachedDependencies:` + strings.Replace(fmt.Sprintf("%v", this.CachedDependencies), "CachedDependency", "CachedDependency", 1) + `,`,
		`LegacyDownloadUser:` + fmt.Sprintf("%v", this.LegacyDownloadUser) + `,`,
		`TrustedSystemCertificatesPath:` + fmt.Sprintf("%v", this.TrustedSystemCertificatesPath) + `,`,
		`VolumeMounts:` + strings.Replace(fmt.Sprintf("%v", this.VolumeMounts), "VolumeMount", "VolumeMount", 1) + `,`,
		`Network:` + strings.Replace(fmt.Sprintf("%v", this.Network), "Network", "Network", 1) + `,`,
		`StartTimeoutMs:` + fmt.Sprintf("%v", this.StartTimeoutMs) + `,`,
		`PlacementTags:` + fmt.Sprintf("%v", this.PlacementTags) + `,`,
		`MaxPids:` + fmt.Sprintf("%v", this.MaxPids) + `,`,
		`CertificateProperties:` + strings.Replace(fmt.Sprintf("%v", this.CertificateProperties), "CertificateProperties", "CertificateProperties", 1) + `,`,
		`ImageUsername:` + fmt.Sprintf("%v", this.ImageUsername) + `,`,
		`ImagePassword:` + fmt.Sprintf("%v", this.ImagePassword) + `,`,
		`CheckDefinition:` + strings.Replace(fmt.Sprintf("%v", this.CheckDefinition), "CheckDefinition", "CheckDefinition", 1) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringDesiredLrp(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *DesiredLRPSchedulingInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDesiredLrp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DesiredLRPSchedulingInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DesiredLRPSchedulingInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DesiredLRPKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDesiredLrp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDesiredLrp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.DesiredLRPKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotation", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDesiredLrp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDesiredLrp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Annotation = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Instances", wireType)
			}
			m.Instances = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDesiredLrp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Instances |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DesiredLRPResource", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDesiredLrp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDesiredLrp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.DesiredLRPResource.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Routes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDesiredLrp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDesiredLrp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Routes.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModificationTag", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDesiredLrp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDesiredLrp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ModificationTag.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolumePlacement", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDesiredLrp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDesiredLrp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VolumePlacement == nil {
				m.VolumePlacement = &VolumePlacement{}
			}
			if err := m.VolumePlacement.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlacementTags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDesiredLrp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDesiredLrp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PlacementTags = append(m.PlacementTags, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDesiredLrp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDesiredLrp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DesiredLRPRunInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDesiredLrp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DesiredLRPRunInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DesiredLRPRunInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DesiredLRPKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDesiredLrp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDesiredLrp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.DesiredLRPKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnvironmentVariables", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDesiredLrp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDesiredLrp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EnvironmentVariables = append(m.EnvironmentVariables, EnvironmentVariable{})
			if err := m.EnvironmentVariables[len(m.EnvironmentVariables)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Setup", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDesiredLrp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDesiredLrp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Setup == nil {
				m.Setup = &Action{}
			}
			if err := m.Setup.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Action", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDesiredLrp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDesiredLrp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Action == nil {
				m.Action = &Action{}
			}
			if err := m.Action.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Monitor", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDesiredLrp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDesiredLrp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Monitor == nil {
				m.Monitor = &Action{}
			}
			if err := m.Monitor.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeprecatedStartTimeoutS", wireType)
			}
			m.DeprecatedStartTimeoutS = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDesiredLrp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DeprecatedStartTimeoutS |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Privileged", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDesiredLrp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Privileged = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuWeight", wireType)
			}
			m.CpuWeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDesiredLrp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CpuWeight |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDesiredLrp
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Ports = append(m.Ports, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDesiredLrp
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthDesiredLrp
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDesiredLrp
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Ports = append(m.Ports, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Ports", wireType)
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EgressRules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDesiredLrp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDesiredLrp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EgressRules = append(m.EgressRules, SecurityGroupRule{})
			if err := m.EgressRules[len(m.EgressRules)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogSource", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDesiredLrp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDesiredLrp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LogSource = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MetricsGuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDesiredLrp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDesiredLrp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MetricsGuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			m.CreatedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDesiredLrp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreatedAt |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CachedDependencies", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDesiredLrp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDesiredLrp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CachedDependencies = append(m.CachedDependencies, &CachedDependency{})
			if err := m.CachedDependencies[len(m.CachedDependencies)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LegacyDownloadUser", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDesiredLrp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDesiredLrp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LegacyDownloadUser = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrustedSystemCertificatesPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDesiredLrp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDesiredLrp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TrustedSystemCertificatesPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolumeMounts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDesiredLrp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDesiredLrp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VolumeMounts = append(m.VolumeMounts, &VolumeMount{})
			if err := m.VolumeMounts[len(m.VolumeMounts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Network", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDesiredLrp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDesiredLrp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Network == nil {
				m.Network = &Network{}
			}
			if err := m.Network.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTimeoutMs", wireType)
			}
			m.StartTimeoutMs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDesiredLrp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartTimeoutMs |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CertificateProperties", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDesiredLrp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDesiredLrp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CertificateProperties == nil {
				m.CertificateProperties = &CertificateProperties{}
			}
			if err := m.CertificateProperties.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImageUsername", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDesiredLrp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDesiredLrp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ImageUsername = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImagePassword", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDesiredLrp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDesiredLrp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ImagePassword = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CheckDefinition", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDesiredLrp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDesiredLrp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CheckDefinition == nil {
				m.CheckDefinition = &CheckDefinition{}
			}
			if err := m.CheckDefinition.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDesiredLrp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDesiredLrp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProtoRoutes) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDesiredLrp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProtoRoutes: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProtoRoutes: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Routes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDesiredLrp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDesiredLrp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDesiredLrp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDesiredLrp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthDesiredLrp
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(dAtA[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			if m.Routes == nil {
				m.Routes = make(map[string][]byte)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDesiredLrp
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapbyteLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDesiredLrp
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					mapbyteLen |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intMapbyteLen := int(mapbyteLen)
				if intMapbyteLen < 0 {
					return ErrInvalidLengthDesiredLrp
				}
				postbytesIndex := iNdEx + intMapbyteLen
				if postbytesIndex > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := make([]byte, mapbyteLen)
				copy(mapvalue, dAtA[iNdEx:postbytesIndex])
				iNdEx = postbytesIndex
				m.Routes[mapkey] = mapvalue
			} else {
				var mapvalue []byte
				m.Routes[mapkey] = mapvalue
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDesiredLrp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDesiredLrp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DesiredLRPUpdate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDesiredLrp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DesiredLRPUpdate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DesiredLRPUpdate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Instances", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDesiredLrp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Instances = &v
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Routes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDesiredLrp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDesiredLrp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Routes == nil {
				m.Routes = &Routes{}
			}
			if err := m.Routes.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotation", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDesiredLrp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDesiredLrp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Annotation = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDesiredLrp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDesiredLrp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DesiredLRPKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDesiredLrp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DesiredLRPKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DesiredLRPKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProcessGuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDesiredLrp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDesiredLrp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProcessGuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Domain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDesiredLrp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDesiredLrp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Domain = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogGuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDesiredLrp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDesiredLrp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LogGuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDesiredLrp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDesiredLrp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DesiredLRPResource) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDesiredLrp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DesiredLRPResource: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DesiredLRPResource: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemoryMb", wireType)
			}
			m.MemoryMb = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDesiredLrp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MemoryMb |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiskMb", wireType)
			}
			m.DiskMb = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDesiredLrp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DiskMb |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RootFs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDesiredLrp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDesiredLrp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RootFs = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxPids", wireType)
			}
			m.MaxPids = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDesiredLrp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxPids |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDesiredLrp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDesiredLrp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DesiredLRP) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDesiredLrp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DesiredLRP: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DesiredLRP: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProcessGuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDesiredLrp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDesiredLrp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProcessGuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Domain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDesiredLrp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDesiredLrp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Domain = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RootFs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDesiredLrp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDesiredLrp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RootFs = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Instances", wireType)
			}
			m.Instances = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDesiredLrp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Instances |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnvironmentVariables", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDesiredLrp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDesiredLrp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EnvironmentVariables = append(m.EnvironmentVariables, &EnvironmentVariable{})
			if err := m.EnvironmentVariables[len(m.EnvironmentVariables)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Setup", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDesiredLrp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDesiredLrp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Setup == nil {
				m.Setup = &Action{}
			}
			if err := m.Setup.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Action", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDesiredLrp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDesiredLrp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Action == nil {
				m.Action = &Action{}
			}
			if err := m.Action.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeprecatedStartTimeoutS", wireType)
			}
			m.DeprecatedStartTimeoutS = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDesiredLrp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DeprecatedStartTimeoutS |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Monitor", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDesiredLrp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDesiredLrp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Monitor == nil {
				m.Monitor = &Action{}
			}
			if err := m.Monitor.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiskMb", wireType)
			}
			m.DiskMb = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDesiredLrp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DiskMb |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemoryMb", wireType)
			}
			m.MemoryMb = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDesiredLrp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MemoryMb |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuWeight", wireType)
			}
			m.CpuWeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDesiredLrp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CpuWeight |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Privileged", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDesiredLrp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Privileged = bool(v != 0)
		case 14:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDesiredLrp
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Ports = append(m.Ports, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDesiredLrp
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthDesiredLrp
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDesiredLrp
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Ports = append(m.Ports, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Ports", wireType)
			}
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Routes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDesiredLrp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDesiredLrp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Routes == nil {
				m.Routes = &Routes{}
			}
			if err := m.Routes.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogSource", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDesiredLrp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDesiredLrp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LogSource = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogGuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDesiredLrp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDesiredLrp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LogGuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MetricsGuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDesiredLrp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDesiredLrp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MetricsGuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotation", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDesiredLrp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDesiredLrp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Annotation = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EgressRules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDesiredLrp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDesiredLrp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EgressRules = append(m.EgressRules, &SecurityGroupRule{})
			if err := m.EgressRules[len(m.EgressRules)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModificationTag", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDesiredLrp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDesiredLrp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ModificationTag == nil {
				m.ModificationTag = &ModificationTag{}
			}
			if err := m.ModificationTag.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CachedDependencies", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDesiredLrp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDesiredLrp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CachedDependencies = append(m.CachedDependencies, &CachedDependency{})
			if err := m.CachedDependencies[len(m.CachedDependencies)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LegacyDownloadUser", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDesiredLrp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDesiredLrp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LegacyDownloadUser = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrustedSystemCertificatesPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDesiredLrp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDesiredLrp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TrustedSystemCertificatesPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolumeMounts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDesiredLrp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDesiredLrp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VolumeMounts = append(m.VolumeMounts, &VolumeMount{})
			if err := m.VolumeMounts[len(m.VolumeMounts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Network", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDesiredLrp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDesiredLrp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Network == nil {
				m.Network = &Network{}
			}
			if err := m.Network.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 27:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTimeoutMs", wireType)
			}
			m.StartTimeoutMs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDesiredLrp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartTimeoutMs |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlacementTags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDesiredLrp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDesiredLrp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PlacementTags = append(m.PlacementTags, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 29:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxPids", wireType)
			}
			m.MaxPids = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDesiredLrp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxPids |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CertificateProperties", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDesiredLrp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDesiredLrp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CertificateProperties == nil {
				m.CertificateProperties = &CertificateProperties{}
			}
			if err := m.CertificateProperties.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImageUsername", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDesiredLrp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDesiredLrp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ImageUsername = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 32:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImagePassword", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDesiredLrp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDesiredLrp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ImagePassword = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 33:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CheckDefinition", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDesiredLrp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDesiredLrp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CheckDefinition == nil {
				m.CheckDefinition = &CheckDefinition{}
			}
			if err := m.CheckDefinition.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDesiredLrp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDesiredLrp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipDesiredLrp(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowDesiredLrp
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDesiredLrp
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDesiredLrp
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthDesiredLrp
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowDesiredLrp
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipDesiredLrp(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthDesiredLrp = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowDesiredLrp   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("desired_lrp.proto", fileDescriptorDesiredLrp) }

var fileDescriptorDesiredLrp = []byte{
	// 1565 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x57, 0xcd, 0x6f, 0xdb, 0x46,
	0x16, 0x37, 0x2d, 0x5b, 0xb2, 0x47, 0x92, 0x3f, 0xc6, 0x5f, 0x8c, 0x6c, 0x4b, 0xb2, 0x36, 0x48,
	0xb4, 0x8b, 0xac, 0x03, 0xf8, 0xb2, 0x8b, 0xdd, 0x3d, 0x6c, 0x18, 0xa7, 0x41, 0x91, 0xb8, 0x10,
	0xe4, 0x38, 0xfd, 0x00, 0x5a, 0x82, 0x26, 0xc7, 0x34, 0x61, 0x92, 0x43, 0xcc, 0x0c, 0xe5, 0x08,
	0x05, 0x8a, 0xfe, 0x03, 0x05, 0x7a, 0xed, 0xad, 0xc7, 0xde, 0x7b, 0xec, 0xb5, 0x87, 0x1c, 0x73,
	0x2c, 0x7a, 0x10, 0x1a, 0xf7, 0x52, 0xf8, 0x94, 0x3f, 0xa1, 0x98, 0xe1, 0x50, 0x1a, 0xca, 0xb4,
	0xe3, 0x00, 0x46, 0x7a, 0x92, 0xe6, 0xbd, 0xdf, 0x7b, 0xf3, 0x66, 0xe6, 0x7d, 0xfc, 0x08, 0x16,
	0x1d, 0x44, 0x3d, 0x82, 0x1c, 0xd3, 0x27, 0xd1, 0x76, 0x44, 0x30, 0xc3, 0xb0, 0x18, 0x60, 0x07,
	0xf9, 0xb4, 0xf6, 0x4f, 0xd7, 0x63, 0xc7, 0xf1, 0xe1, 0xb6, 0x8d, 0x83, 0xfb, 0x2e, 0x76, 0xf1,
	0x7d, 0xa1, 0x3e, 0x8c, 0x8f, 0xc4, 0x4a, 0x2c, 0xc4, 0xbf, 0xc4, 0xac, 0x56, 0xb5, 0x6c, 0xe6,
	0xe1, 0x90, 0xca, 0xe5, 0x9a, 0x6d, 0xd9, 0xc7, 0xc8, 0x31, 0x1d, 0x14, 0xa1, 0xd0, 0x41, 0xa1,
	0xdd, 0x97, 0x8a, 0x0d, 0x1b, 0x11, 0xe6, 0x1d, 0x79, 0xb6, 0xc5, 0x90, 0x19, 0x11, 0x1c, 0xf1,
	0x25, 0x4a, 0xcd, 0xd6, 0x51, 0xd8, 0xf3, 0x08, 0x0e, 0x03, 0x14, 0x32, 0xb3, 0x67, 0x11, 0xcf,
	0x3a, 0xf4, 0x87, 0xca, 0xd5, 0x00, 0x3b, 0x89, 0xa5, 0x87, 0x43, 0x93, 0x59, 0x6e, 0xba, 0x75,
	0x88, 0xd8, 0x29, 0x26, 0x27, 0x72, 0xb9, 0x4c, 0x91, 0x1d, 0x13, 0x8f, 0xf5, 0x4d, 0x97, 0xe0,
	0x58, 0x1e, 0xab, 0x06, 0x7b, 0xd8, 0x8f, 0x03, 0x64, 0x06, 0x38, 0x0e, 0x59, 0xea, 0xd0, 0x3e,
	0x46, 0xf6, 0x89, 0xe9, 0xa0, 0x23, 0x2f, 0xf4, 0xb8, 0xd3, 0x44, 0xde, 0xfa, 0x79, 0x0a, 0xe8,
	0xbb, 0xc9, 0xc5, 0x3c, 0xed, 0x76, 0xf6, 0xf9, 0x41, 0x62, 0xdf, 0x0b, 0xdd, 0x0f, 0xc3, 0x23,
	0x0c, 0x9f, 0x80, 0x79, 0xe5, 0xd2, 0xcc, 0x13, 0xd4, 0xd7, 0xb5, 0xa6, 0xd6, 0x2e, 0xef, 0xac,
	0x6c, 0x27, 0x37, 0xb7, 0x3d, 0x32, 0x7d, 0x82, 0xfa, 0x46, 0xe5, 0xe5, 0xa0, 0x31, 0xf1, 0x6a,
	0xd0, 0xd0, 0xce, 0x07, 0x8d, 0x89, 0x6e, 0x55, 0xda, 0x3e, 0x25, 0xd1, 0x13, 0xd4, 0x87, 0xb7,
	0x01, 0xb0, 0xc2, 0x10, 0x33, 0x71, 0x24, 0x7d, 0xb2, 0xa9, 0xb5, 0x67, 0x8d, 0x29, 0x6e, 0xd0,
	0x55, 0xe4, 0xb0, 0x05, 0x66, 0xbd, 0x90, 0x32, 0x2b, 0xb4, 0x11, 0xd5, 0x0b, 0x4d, 0xad, 0x3d,
	0x2d, 0x41, 0x23, 0x31, 0xfc, 0x0c, 0x2c, 0xab, 0x61, 0x11, 0x44, 0x71, 0x4c, 0x6c, 0xa4, 0x4f,
	0x89, 0xd8, 0x6a, 0x17, 0x63, 0xeb, 0x4a, 0xc4, 0x58, 0x80, 0x70, 0x14, 0x60, 0x8a, 0x80, 0xff,
	0x05, 0x45, 0x82, 0x63, 0x86, 0xa8, 0x3e, 0x2d, 0xbc, 0x2d, 0xa5, 0xde, 0x3a, 0xfc, 0xba, 0xba,
	0x42, 0x65, 0xcc, 0x71, 0x37, 0xbf, 0x0e, 0x1a, 0xc5, 0x64, 0xdd, 0x95, 0x26, 0xb0, 0x03, 0x16,
	0xc6, 0xdf, 0x4d, 0x2f, 0x0a, 0x37, 0x6b, 0xa9, 0x9b, 0x3d, 0x45, 0xff, 0xcc, 0x72, 0xc7, 0x22,
	0x9a, 0x0f, 0xb2, 0x6a, 0x78, 0x08, 0x16, 0xe4, 0x63, 0x46, 0xbe, 0x65, 0x23, 0x9e, 0x2b, 0x7a,
	0x29, 0xeb, 0xf1, 0xb9, 0xd0, 0x77, 0x52, 0xb5, 0x51, 0x3f, 0x1f, 0x34, 0x6a, 0xe3, 0x46, 0xf7,
	0x70, 0xe0, 0x31, 0x14, 0x44, 0xac, 0xdf, 0x9d, 0xef, 0x65, 0x0d, 0xa0, 0x01, 0xaa, 0xc3, 0xc5,
	0x33, 0xcb, 0xa5, 0xfa, 0x4c, 0xb3, 0xd0, 0x9e, 0x35, 0x36, 0xce, 0x07, 0x0d, 0x7d, 0xe8, 0x80,
	0x9f, 0x85, 0x2a, 0x5e, 0xb2, 0x26, 0xad, 0x1f, 0x2b, 0x60, 0x51, 0xb9, 0xef, 0x38, 0xbc, 0xf9,
	0xfc, 0xf9, 0x1c, 0xac, 0xe4, 0x56, 0x8c, 0x3e, 0xd9, 0x2c, 0xb4, 0xcb, 0x3b, 0xeb, 0xa9, 0xcb,
	0x47, 0x23, 0xd0, 0x73, 0x89, 0x31, 0xca, 0xdc, 0xf1, 0xf9, 0xa0, 0x51, 0x40, 0x61, 0xaf, 0xbb,
	0x8c, 0x2e, 0x22, 0x28, 0xbc, 0x0d, 0xa6, 0x29, 0x62, 0x71, 0x24, 0x92, 0xae, 0xbc, 0x33, 0x97,
	0xba, 0x7b, 0x20, 0x6a, 0xbd, 0x9b, 0x28, 0xe1, 0x1d, 0x50, 0x4c, 0x8a, 0x5f, 0x26, 0xdb, 0x38,
	0x4c, 0x6a, 0x61, 0x1b, 0x94, 0x02, 0x1c, 0x7a, 0x0c, 0x13, 0x99, 0x47, 0xe3, 0xc0, 0x54, 0x0d,
	0xbf, 0x00, 0x35, 0x07, 0x45, 0x04, 0xf1, 0x26, 0xe1, 0x98, 0x94, 0x59, 0x84, 0x99, 0xcc, 0x0b,
	0x10, 0x8e, 0x99, 0x49, 0x45, 0xf6, 0x54, 0x8d, 0x2d, 0x19, 0xfe, 0x5a, 0x46, 0x3d, 0x7a, 0x0d,
	0x5d, 0xeb, 0xae, 0x8d, 0x9c, 0xec, 0x73, 0xd0, 0xb3, 0x04, 0xb3, 0xcf, 0xcb, 0x2e, 0x22, 0x5e,
	0xcf, 0xf3, 0x91, 0x8b, 0x1c, 0x91, 0x3b, 0x33, 0x69, 0xd9, 0x8d, 0xe4, 0xf0, 0x6f, 0x00, 0xd8,
	0x51, 0x6c, 0x9e, 0x22, 0xcf, 0x3d, 0x66, 0xfa, 0x8c, 0xd8, 0x55, 0xd6, 0x9d, 0x1d, 0xc5, 0x1f,
	0x0b, 0x31, 0x5c, 0x06, 0xd3, 0x11, 0x26, 0x8c, 0xea, 0xb3, 0xcd, 0x42, 0xbb, 0xda, 0x4d, 0x16,
	0xd0, 0x00, 0x15, 0xe4, 0x12, 0x44, 0xa9, 0x49, 0x62, 0xfe, 0x1c, 0x40, 0x3c, 0xc7, 0xad, 0xf4,
	0xbc, 0xfb, 0xb2, 0x43, 0x3d, 0xe6, 0x0d, 0xaa, 0x1b, 0xfb, 0x48, 0xfa, 0x2d, 0x27, 0x46, 0x5c,
	0x42, 0xf9, 0xf6, 0x3e, 0x76, 0x4d, 0x59, 0xc7, 0x65, 0xa5, 0x37, 0xcc, 0xfa, 0xd8, 0xdd, 0x4f,
	0x4a, 0xf3, 0x2e, 0xa8, 0x04, 0x88, 0x11, 0xcf, 0xa6, 0xa6, 0x1b, 0x7b, 0x8e, 0x5e, 0x51, 0x60,
	0x65, 0xa9, 0x79, 0x1c, 0x7b, 0xc9, 0x61, 0x08, 0x12, 0xf7, 0x69, 0x31, 0xbd, 0xda, 0xd4, 0xda,
	0x85, 0xe1, 0x61, 0x12, 0xf9, 0x03, 0x06, 0x7d, 0xb0, 0x34, 0xde, 0xb7, 0x3d, 0x44, 0xf5, 0x39,
	0x11, 0xbd, 0x9e, 0x46, 0xff, 0x50, 0x40, 0x76, 0x87, 0x9d, 0xdd, 0xd8, 0x3a, 0x1f, 0x34, 0x36,
	0x73, 0x0c, 0x95, 0xd2, 0x80, 0x76, 0xd6, 0xc8, 0x43, 0x14, 0x7e, 0x02, 0x96, 0x7d, 0xe4, 0x5a,
	0x76, 0xdf, 0x74, 0xf0, 0x69, 0xe8, 0x63, 0xcb, 0x31, 0x63, 0x8a, 0x88, 0x3e, 0x2f, 0xce, 0x70,
	0x47, 0xbe, 0x6f, 0x3d, 0x0f, 0xa3, 0x7a, 0x4e, 0xf4, 0xbb, 0x52, 0x7d, 0x40, 0x11, 0x81, 0x5f,
	0x82, 0x26, 0x23, 0x31, 0x15, 0xc9, 0xd3, 0xa7, 0x0c, 0x05, 0xa6, 0x32, 0x75, 0xa8, 0x19, 0x59,
	0xec, 0x58, 0x5f, 0x10, 0xbb, 0xec, 0xc8, 0x5d, 0xfe, 0xf1, 0x36, 0xbc, 0xb2, 0xe3, 0xa6, 0xc4,
	0xee, 0x0b, 0xe8, 0x43, 0x05, 0xd9, 0xb1, 0xd8, 0x31, 0x3c, 0x00, 0x55, 0x75, 0xd6, 0x50, 0x7d,
	0x51, 0x5c, 0xdf, 0x52, 0xb6, 0x37, 0xed, 0x71, 0x9d, 0xb1, 0xce, 0x13, 0x38, 0x83, 0x56, 0xf6,
	0xa9, 0xf4, 0x46, 0x48, 0x0a, 0xff, 0x0f, 0x4a, 0x72, 0xce, 0xe9, 0x50, 0x54, 0xcf, 0x7c, 0xea,
	0xf0, 0xa3, 0x44, 0x6c, 0xac, 0x9c, 0x0f, 0x1a, 0x8b, 0x12, 0xa3, 0xb8, 0x49, 0xcd, 0xe0, 0x36,
	0x58, 0xc8, 0x96, 0x52, 0x40, 0xf5, 0x25, 0x25, 0x11, 0xe6, 0xa8, 0x52, 0x24, 0x7b, 0x14, 0x7e,
	0x05, 0x56, 0xf3, 0x87, 0xb5, 0xbe, 0x2c, 0x02, 0xd8, 0x1c, 0x26, 0xc4, 0x08, 0xd5, 0x19, 0x82,
	0x8c, 0xf6, 0xcb, 0xa4, 0x69, 0x35, 0xf3, 0x9d, 0x28, 0x11, 0xae, 0xd8, 0x79, 0x0e, 0xe0, 0x63,
	0x30, 0xe7, 0x05, 0x96, 0x8b, 0xc4, 0x8b, 0x87, 0x56, 0x80, 0xf4, 0x15, 0xf1, 0x66, 0x4d, 0xf9,
	0x66, 0x7a, 0x56, 0xab, 0x36, 0x62, 0xa1, 0x39, 0x90, 0x8a, 0x91, 0xa3, 0xc8, 0xa2, 0xf4, 0x14,
	0x13, 0x47, 0x5f, 0xcd, 0x73, 0x94, 0x6a, 0x2f, 0x38, 0xea, 0x48, 0x05, 0x9f, 0x3c, 0xe3, 0x94,
	0x41, 0x5f, 0xcb, 0x4e, 0x9e, 0x87, 0x5c, 0xbf, 0x3b, 0x54, 0x27, 0x93, 0x67, 0xdc, 0x48, 0x9d,
	0x3c, 0x76, 0xd6, 0xa0, 0xf5, 0x8d, 0x06, 0xca, 0xca, 0x5c, 0x85, 0xff, 0x1a, 0x0e, 0x5f, 0x4d,
	0xe4, 0x51, 0x23, 0x67, 0xf8, 0x6e, 0x27, 0x3f, 0x8f, 0x42, 0x46, 0xfa, 0xe9, 0xe0, 0xad, 0x3d,
	0x02, 0x65, 0x45, 0x0c, 0x57, 0x41, 0x21, 0x9d, 0x35, 0x69, 0x83, 0xe0, 0x02, 0x58, 0x03, 0xd3,
	0x3d, 0xcb, 0x8f, 0x91, 0x60, 0x1f, 0x15, 0xa9, 0x49, 0x44, 0xff, 0x99, 0xfc, 0xb7, 0xd6, 0xfa,
	0x4e, 0x03, 0x0b, 0xa3, 0x89, 0x74, 0x10, 0x39, 0x16, 0x43, 0x59, 0x46, 0xa2, 0x0d, 0x19, 0x89,
	0xa6, 0x32, 0x92, 0x11, 0x6b, 0x98, 0xbc, 0x9a, 0x35, 0x68, 0x39, 0xac, 0x21, 0x4b, 0x8c, 0x0a,
	0xc3, 0xa0, 0x35, 0x95, 0x18, 0xb5, 0x4e, 0x41, 0x35, 0x33, 0x2c, 0x79, 0x3b, 0x8c, 0x08, 0xb6,
	0x79, 0xe3, 0x15, 0xed, 0x50, 0x3d, 0x6d, 0x59, 0x6a, 0x44, 0x3b, 0xdc, 0x00, 0x45, 0x07, 0x07,
	0x96, 0x97, 0x25, 0x5d, 0x52, 0x06, 0x1b, 0x60, 0x86, 0xb7, 0x5e, 0xe1, 0xa2, 0xa0, 0xe8, 0x4b,
	0x3e, 0x76, 0xb9, 0x79, 0xeb, 0x7b, 0x0d, 0xc0, 0x8b, 0x54, 0x0a, 0x6e, 0x81, 0xd9, 0x00, 0x05,
	0x98, 0xf4, 0xcd, 0xe0, 0x50, 0xb9, 0x96, 0x89, 0xee, 0x4c, 0x22, 0xde, 0x3b, 0x84, 0x9b, 0xa0,
	0xe4, 0x78, 0xf4, 0x84, 0x03, 0x26, 0x15, 0x40, 0x91, 0x0b, 0xf7, 0x0e, 0xe1, 0x5d, 0x50, 0x22,
	0x18, 0x33, 0xf3, 0x88, 0xca, 0x8d, 0xe7, 0x64, 0x8e, 0x16, 0xb9, 0xf8, 0x48, 0x5c, 0x10, 0x66,
	0x1f, 0x50, 0x1e, 0x62, 0x60, 0xbd, 0x30, 0x23, 0xcf, 0xa1, 0x62, 0xec, 0xa6, 0x8e, 0x4a, 0x81,
	0xf5, 0xa2, 0xe3, 0x39, 0xb4, 0xf5, 0xd3, 0x3c, 0x00, 0xa3, 0x10, 0x6f, 0xea, 0x66, 0xae, 0x1d,
	0x5f, 0x26, 0x43, 0xa6, 0xf2, 0x39, 0xeb, 0xa7, 0x97, 0xb1, 0x97, 0xe9, 0xb7, 0xb3, 0x97, 0xd2,
	0x35, 0x99, 0x4b, 0xf1, 0x7a, 0xcc, 0xa5, 0x74, 0x25, 0x73, 0x39, 0xba, 0x92, 0x8f, 0x24, 0xcc,
	0xe0, 0xef, 0xf2, 0x22, 0x1a, 0x0a, 0x32, 0xc5, 0x84, 0xf4, 0x7a, 0xbc, 0x44, 0x61, 0x48, 0xb3,
	0x57, 0x33, 0x24, 0x25, 0x8d, 0x40, 0x4e, 0x1a, 0x65, 0x12, 0xb1, 0x9c, 0x9b, 0x88, 0x59, 0x76,
	0x53, 0xc9, 0x67, 0x37, 0x59, 0xa2, 0x54, 0xbd, 0x84, 0x28, 0x0d, 0x39, 0xd0, 0x9c, 0xca, 0x81,
	0x46, 0xf5, 0x3f, 0xff, 0xee, 0xf5, 0x9f, 0x25, 0x3f, 0x0b, 0xf9, 0xe4, 0x47, 0x2d, 0xd3, 0xc5,
	0x9c, 0x32, 0xbd, 0xc0, 0x8e, 0xe0, 0x65, 0xec, 0x28, 0xdb, 0x6e, 0x96, 0x2e, 0xf9, 0x0e, 0xfb,
	0xdf, 0x18, 0xab, 0x5b, 0x7e, 0x0b, 0xab, 0xcb, 0xf2, 0x39, 0x23, 0xe7, 0x43, 0x68, 0xe5, 0xca,
	0x0f, 0xa1, 0x8b, 0x9f, 0x3e, 0x97, 0x10, 0xb4, 0xd5, 0xf7, 0x4b, 0xd0, 0xd6, 0xde, 0x0b, 0x41,
	0xd3, 0xdf, 0x1b, 0x41, 0xbb, 0x75, 0xd3, 0x04, 0xad, 0x76, 0x73, 0x04, 0x6d, 0xfd, 0x0a, 0x82,
	0x76, 0xe1, 0x23, 0x75, 0xe3, 0x9d, 0x3f, 0x52, 0x33, 0x73, 0x64, 0x33, 0x67, 0x8e, 0x5c, 0xc1,
	0x02, 0xeb, 0x7f, 0x11, 0x0b, 0x6c, 0xdc, 0x14, 0x0b, 0x6c, 0xde, 0x1c, 0x0b, 0xdc, 0xba, 0x59,
	0x16, 0x68, 0xdc, 0x7b, 0xf5, 0xba, 0x3e, 0xf1, 0xcb, 0xeb, 0xfa, 0xc4, 0x9b, 0xd7, 0x75, 0xed,
	0xeb, 0xb3, 0xba, 0xf6, 0xc3, 0x59, 0x5d, 0x7b, 0x79, 0x56, 0xd7, 0x5e, 0x9d, 0xd5, 0xb5, 0xdf,
	0xce, 0xea, 0xda, 0x1f, 0x67, 0xf5, 0x89, 0x37, 0x67, 0x75, 0xed, 0xdb, 0xdf, 0xeb, 0x13, 0x7f,
	0x06, 0x00, 0x00, 0xff, 0xff, 0xb3, 0x50, 0x4a, 0x1d, 0xc7, 0x13, 0x00, 0x00,
}
