// This file was generated by counterfeiter
package fakes

import (
	"sync"

	bbs_etcd "code.cloudfoundry.org/bbs/db/etcd"
	"github.com/coreos/go-etcd/etcd"
)

type FakeStoreClient struct {
	GetStub        func(key string, sort bool, recursive bool) (*etcd.Response, error)
	getMutex       sync.RWMutex
	getArgsForCall []struct {
		key       string
		sort      bool
		recursive bool
	}
	getReturns struct {
		result1 *etcd.Response
		result2 error
	}
	SetStub        func(key string, value []byte, ttl uint64) (*etcd.Response, error)
	setMutex       sync.RWMutex
	setArgsForCall []struct {
		key   string
		value []byte
		ttl   uint64
	}
	setReturns struct {
		result1 *etcd.Response
		result2 error
	}
	CreateStub        func(key string, value []byte, ttl uint64) (*etcd.Response, error)
	createMutex       sync.RWMutex
	createArgsForCall []struct {
		key   string
		value []byte
		ttl   uint64
	}
	createReturns struct {
		result1 *etcd.Response
		result2 error
	}
	DeleteStub        func(key string, recursive bool) (*etcd.Response, error)
	deleteMutex       sync.RWMutex
	deleteArgsForCall []struct {
		key       string
		recursive bool
	}
	deleteReturns struct {
		result1 *etcd.Response
		result2 error
	}
	DeleteDirStub        func(key string) (*etcd.Response, error)
	deleteDirMutex       sync.RWMutex
	deleteDirArgsForCall []struct {
		key string
	}
	deleteDirReturns struct {
		result1 *etcd.Response
		result2 error
	}
	CompareAndSwapStub        func(key string, value []byte, ttl uint64, prevIndex uint64) (*etcd.Response, error)
	compareAndSwapMutex       sync.RWMutex
	compareAndSwapArgsForCall []struct {
		key       string
		value     []byte
		ttl       uint64
		prevIndex uint64
	}
	compareAndSwapReturns struct {
		result1 *etcd.Response
		result2 error
	}
	CompareAndDeleteStub        func(key string, prevIndex uint64) (*etcd.Response, error)
	compareAndDeleteMutex       sync.RWMutex
	compareAndDeleteArgsForCall []struct {
		key       string
		prevIndex uint64
	}
	compareAndDeleteReturns struct {
		result1 *etcd.Response
		result2 error
	}
	WatchStub        func(prefix string, waitIndex uint64, recursive bool, receiver chan *etcd.Response, stop chan bool) (*etcd.Response, error)
	watchMutex       sync.RWMutex
	watchArgsForCall []struct {
		prefix    string
		waitIndex uint64
		recursive bool
		receiver  chan *etcd.Response
		stop      chan bool
	}
	watchReturns struct {
		result1 *etcd.Response
		result2 error
	}
}

func (fake *FakeStoreClient) Get(key string, sort bool, recursive bool) (*etcd.Response, error) {
	fake.getMutex.Lock()
	fake.getArgsForCall = append(fake.getArgsForCall, struct {
		key       string
		sort      bool
		recursive bool
	}{key, sort, recursive})
	fake.getMutex.Unlock()
	if fake.GetStub != nil {
		return fake.GetStub(key, sort, recursive)
	} else {
		return fake.getReturns.result1, fake.getReturns.result2
	}
}

func (fake *FakeStoreClient) GetCallCount() int {
	fake.getMutex.RLock()
	defer fake.getMutex.RUnlock()
	return len(fake.getArgsForCall)
}

func (fake *FakeStoreClient) GetArgsForCall(i int) (string, bool, bool) {
	fake.getMutex.RLock()
	defer fake.getMutex.RUnlock()
	return fake.getArgsForCall[i].key, fake.getArgsForCall[i].sort, fake.getArgsForCall[i].recursive
}

func (fake *FakeStoreClient) GetReturns(result1 *etcd.Response, result2 error) {
	fake.GetStub = nil
	fake.getReturns = struct {
		result1 *etcd.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeStoreClient) Set(key string, value []byte, ttl uint64) (*etcd.Response, error) {
	fake.setMutex.Lock()
	fake.setArgsForCall = append(fake.setArgsForCall, struct {
		key   string
		value []byte
		ttl   uint64
	}{key, value, ttl})
	fake.setMutex.Unlock()
	if fake.SetStub != nil {
		return fake.SetStub(key, value, ttl)
	} else {
		return fake.setReturns.result1, fake.setReturns.result2
	}
}

func (fake *FakeStoreClient) SetCallCount() int {
	fake.setMutex.RLock()
	defer fake.setMutex.RUnlock()
	return len(fake.setArgsForCall)
}

func (fake *FakeStoreClient) SetArgsForCall(i int) (string, []byte, uint64) {
	fake.setMutex.RLock()
	defer fake.setMutex.RUnlock()
	return fake.setArgsForCall[i].key, fake.setArgsForCall[i].value, fake.setArgsForCall[i].ttl
}

func (fake *FakeStoreClient) SetReturns(result1 *etcd.Response, result2 error) {
	fake.SetStub = nil
	fake.setReturns = struct {
		result1 *etcd.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeStoreClient) Create(key string, value []byte, ttl uint64) (*etcd.Response, error) {
	fake.createMutex.Lock()
	fake.createArgsForCall = append(fake.createArgsForCall, struct {
		key   string
		value []byte
		ttl   uint64
	}{key, value, ttl})
	fake.createMutex.Unlock()
	if fake.CreateStub != nil {
		return fake.CreateStub(key, value, ttl)
	} else {
		return fake.createReturns.result1, fake.createReturns.result2
	}
}

func (fake *FakeStoreClient) CreateCallCount() int {
	fake.createMutex.RLock()
	defer fake.createMutex.RUnlock()
	return len(fake.createArgsForCall)
}

func (fake *FakeStoreClient) CreateArgsForCall(i int) (string, []byte, uint64) {
	fake.createMutex.RLock()
	defer fake.createMutex.RUnlock()
	return fake.createArgsForCall[i].key, fake.createArgsForCall[i].value, fake.createArgsForCall[i].ttl
}

func (fake *FakeStoreClient) CreateReturns(result1 *etcd.Response, result2 error) {
	fake.CreateStub = nil
	fake.createReturns = struct {
		result1 *etcd.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeStoreClient) Delete(key string, recursive bool) (*etcd.Response, error) {
	fake.deleteMutex.Lock()
	fake.deleteArgsForCall = append(fake.deleteArgsForCall, struct {
		key       string
		recursive bool
	}{key, recursive})
	fake.deleteMutex.Unlock()
	if fake.DeleteStub != nil {
		return fake.DeleteStub(key, recursive)
	} else {
		return fake.deleteReturns.result1, fake.deleteReturns.result2
	}
}

func (fake *FakeStoreClient) DeleteCallCount() int {
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	return len(fake.deleteArgsForCall)
}

func (fake *FakeStoreClient) DeleteArgsForCall(i int) (string, bool) {
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	return fake.deleteArgsForCall[i].key, fake.deleteArgsForCall[i].recursive
}

func (fake *FakeStoreClient) DeleteReturns(result1 *etcd.Response, result2 error) {
	fake.DeleteStub = nil
	fake.deleteReturns = struct {
		result1 *etcd.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeStoreClient) DeleteDir(key string) (*etcd.Response, error) {
	fake.deleteDirMutex.Lock()
	fake.deleteDirArgsForCall = append(fake.deleteDirArgsForCall, struct {
		key string
	}{key})
	fake.deleteDirMutex.Unlock()
	if fake.DeleteDirStub != nil {
		return fake.DeleteDirStub(key)
	} else {
		return fake.deleteDirReturns.result1, fake.deleteDirReturns.result2
	}
}

func (fake *FakeStoreClient) DeleteDirCallCount() int {
	fake.deleteDirMutex.RLock()
	defer fake.deleteDirMutex.RUnlock()
	return len(fake.deleteDirArgsForCall)
}

func (fake *FakeStoreClient) DeleteDirArgsForCall(i int) string {
	fake.deleteDirMutex.RLock()
	defer fake.deleteDirMutex.RUnlock()
	return fake.deleteDirArgsForCall[i].key
}

func (fake *FakeStoreClient) DeleteDirReturns(result1 *etcd.Response, result2 error) {
	fake.DeleteDirStub = nil
	fake.deleteDirReturns = struct {
		result1 *etcd.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeStoreClient) CompareAndSwap(key string, value []byte, ttl uint64, prevIndex uint64) (*etcd.Response, error) {
	fake.compareAndSwapMutex.Lock()
	fake.compareAndSwapArgsForCall = append(fake.compareAndSwapArgsForCall, struct {
		key       string
		value     []byte
		ttl       uint64
		prevIndex uint64
	}{key, value, ttl, prevIndex})
	fake.compareAndSwapMutex.Unlock()
	if fake.CompareAndSwapStub != nil {
		return fake.CompareAndSwapStub(key, value, ttl, prevIndex)
	} else {
		return fake.compareAndSwapReturns.result1, fake.compareAndSwapReturns.result2
	}
}

func (fake *FakeStoreClient) CompareAndSwapCallCount() int {
	fake.compareAndSwapMutex.RLock()
	defer fake.compareAndSwapMutex.RUnlock()
	return len(fake.compareAndSwapArgsForCall)
}

func (fake *FakeStoreClient) CompareAndSwapArgsForCall(i int) (string, []byte, uint64, uint64) {
	fake.compareAndSwapMutex.RLock()
	defer fake.compareAndSwapMutex.RUnlock()
	return fake.compareAndSwapArgsForCall[i].key, fake.compareAndSwapArgsForCall[i].value, fake.compareAndSwapArgsForCall[i].ttl, fake.compareAndSwapArgsForCall[i].prevIndex
}

func (fake *FakeStoreClient) CompareAndSwapReturns(result1 *etcd.Response, result2 error) {
	fake.CompareAndSwapStub = nil
	fake.compareAndSwapReturns = struct {
		result1 *etcd.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeStoreClient) CompareAndDelete(key string, prevIndex uint64) (*etcd.Response, error) {
	fake.compareAndDeleteMutex.Lock()
	fake.compareAndDeleteArgsForCall = append(fake.compareAndDeleteArgsForCall, struct {
		key       string
		prevIndex uint64
	}{key, prevIndex})
	fake.compareAndDeleteMutex.Unlock()
	if fake.CompareAndDeleteStub != nil {
		return fake.CompareAndDeleteStub(key, prevIndex)
	} else {
		return fake.compareAndDeleteReturns.result1, fake.compareAndDeleteReturns.result2
	}
}

func (fake *FakeStoreClient) CompareAndDeleteCallCount() int {
	fake.compareAndDeleteMutex.RLock()
	defer fake.compareAndDeleteMutex.RUnlock()
	return len(fake.compareAndDeleteArgsForCall)
}

func (fake *FakeStoreClient) CompareAndDeleteArgsForCall(i int) (string, uint64) {
	fake.compareAndDeleteMutex.RLock()
	defer fake.compareAndDeleteMutex.RUnlock()
	return fake.compareAndDeleteArgsForCall[i].key, fake.compareAndDeleteArgsForCall[i].prevIndex
}

func (fake *FakeStoreClient) CompareAndDeleteReturns(result1 *etcd.Response, result2 error) {
	fake.CompareAndDeleteStub = nil
	fake.compareAndDeleteReturns = struct {
		result1 *etcd.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeStoreClient) Watch(prefix string, waitIndex uint64, recursive bool, receiver chan *etcd.Response, stop chan bool) (*etcd.Response, error) {
	fake.watchMutex.Lock()
	fake.watchArgsForCall = append(fake.watchArgsForCall, struct {
		prefix    string
		waitIndex uint64
		recursive bool
		receiver  chan *etcd.Response
		stop      chan bool
	}{prefix, waitIndex, recursive, receiver, stop})
	fake.watchMutex.Unlock()
	if fake.WatchStub != nil {
		return fake.WatchStub(prefix, waitIndex, recursive, receiver, stop)
	} else {
		return fake.watchReturns.result1, fake.watchReturns.result2
	}
}

func (fake *FakeStoreClient) WatchCallCount() int {
	fake.watchMutex.RLock()
	defer fake.watchMutex.RUnlock()
	return len(fake.watchArgsForCall)
}

func (fake *FakeStoreClient) WatchArgsForCall(i int) (string, uint64, bool, chan *etcd.Response, chan bool) {
	fake.watchMutex.RLock()
	defer fake.watchMutex.RUnlock()
	return fake.watchArgsForCall[i].prefix, fake.watchArgsForCall[i].waitIndex, fake.watchArgsForCall[i].recursive, fake.watchArgsForCall[i].receiver, fake.watchArgsForCall[i].stop
}

func (fake *FakeStoreClient) WatchReturns(result1 *etcd.Response, result2 error) {
	fake.WatchStub = nil
	fake.watchReturns = struct {
		result1 *etcd.Response
		result2 error
	}{result1, result2}
}

var _ bbs_etcd.StoreClient = new(FakeStoreClient)
