// Code generated by counterfeiter. DO NOT EDIT.
package dbfakes

import (
	"sync"

	"code.cloudfoundry.org/bbs/db"
	"code.cloudfoundry.org/bbs/models"
	"code.cloudfoundry.org/lager"
)

type FakeActualLRPDB struct {
	ActualLRPGroupsStub        func(logger lager.Logger, filter models.ActualLRPFilter) ([]*models.ActualLRPGroup, error)
	actualLRPGroupsMutex       sync.RWMutex
	actualLRPGroupsArgsForCall []struct {
		logger lager.Logger
		filter models.ActualLRPFilter
	}
	actualLRPGroupsReturns struct {
		result1 []*models.ActualLRPGroup
		result2 error
	}
	actualLRPGroupsReturnsOnCall map[int]struct {
		result1 []*models.ActualLRPGroup
		result2 error
	}
	ActualLRPGroupsByProcessGuidStub        func(logger lager.Logger, processGuid string) ([]*models.ActualLRPGroup, error)
	actualLRPGroupsByProcessGuidMutex       sync.RWMutex
	actualLRPGroupsByProcessGuidArgsForCall []struct {
		logger      lager.Logger
		processGuid string
	}
	actualLRPGroupsByProcessGuidReturns struct {
		result1 []*models.ActualLRPGroup
		result2 error
	}
	actualLRPGroupsByProcessGuidReturnsOnCall map[int]struct {
		result1 []*models.ActualLRPGroup
		result2 error
	}
	ActualLRPGroupByProcessGuidAndIndexStub        func(logger lager.Logger, processGuid string, index int32) (*models.ActualLRPGroup, error)
	actualLRPGroupByProcessGuidAndIndexMutex       sync.RWMutex
	actualLRPGroupByProcessGuidAndIndexArgsForCall []struct {
		logger      lager.Logger
		processGuid string
		index       int32
	}
	actualLRPGroupByProcessGuidAndIndexReturns struct {
		result1 *models.ActualLRPGroup
		result2 error
	}
	actualLRPGroupByProcessGuidAndIndexReturnsOnCall map[int]struct {
		result1 *models.ActualLRPGroup
		result2 error
	}
	CreateUnclaimedActualLRPStub        func(logger lager.Logger, key *models.ActualLRPKey) (after *models.ActualLRPGroup, err error)
	createUnclaimedActualLRPMutex       sync.RWMutex
	createUnclaimedActualLRPArgsForCall []struct {
		logger lager.Logger
		key    *models.ActualLRPKey
	}
	createUnclaimedActualLRPReturns struct {
		result1 *models.ActualLRPGroup
		result2 error
	}
	createUnclaimedActualLRPReturnsOnCall map[int]struct {
		result1 *models.ActualLRPGroup
		result2 error
	}
	UnclaimActualLRPStub        func(logger lager.Logger, key *models.ActualLRPKey) (before *models.ActualLRPGroup, after *models.ActualLRPGroup, err error)
	unclaimActualLRPMutex       sync.RWMutex
	unclaimActualLRPArgsForCall []struct {
		logger lager.Logger
		key    *models.ActualLRPKey
	}
	unclaimActualLRPReturns struct {
		result1 *models.ActualLRPGroup
		result2 *models.ActualLRPGroup
		result3 error
	}
	unclaimActualLRPReturnsOnCall map[int]struct {
		result1 *models.ActualLRPGroup
		result2 *models.ActualLRPGroup
		result3 error
	}
	ClaimActualLRPStub        func(logger lager.Logger, processGuid string, index int32, instanceKey *models.ActualLRPInstanceKey) (before *models.ActualLRPGroup, after *models.ActualLRPGroup, err error)
	claimActualLRPMutex       sync.RWMutex
	claimActualLRPArgsForCall []struct {
		logger      lager.Logger
		processGuid string
		index       int32
		instanceKey *models.ActualLRPInstanceKey
	}
	claimActualLRPReturns struct {
		result1 *models.ActualLRPGroup
		result2 *models.ActualLRPGroup
		result3 error
	}
	claimActualLRPReturnsOnCall map[int]struct {
		result1 *models.ActualLRPGroup
		result2 *models.ActualLRPGroup
		result3 error
	}
	StartActualLRPStub        func(logger lager.Logger, key *models.ActualLRPKey, instanceKey *models.ActualLRPInstanceKey, netInfo *models.ActualLRPNetInfo) (before *models.ActualLRPGroup, after *models.ActualLRPGroup, err error)
	startActualLRPMutex       sync.RWMutex
	startActualLRPArgsForCall []struct {
		logger      lager.Logger
		key         *models.ActualLRPKey
		instanceKey *models.ActualLRPInstanceKey
		netInfo     *models.ActualLRPNetInfo
	}
	startActualLRPReturns struct {
		result1 *models.ActualLRPGroup
		result2 *models.ActualLRPGroup
		result3 error
	}
	startActualLRPReturnsOnCall map[int]struct {
		result1 *models.ActualLRPGroup
		result2 *models.ActualLRPGroup
		result3 error
	}
	CrashActualLRPStub        func(logger lager.Logger, key *models.ActualLRPKey, instanceKey *models.ActualLRPInstanceKey, crashReason string) (before *models.ActualLRPGroup, after *models.ActualLRPGroup, shouldRestart bool, err error)
	crashActualLRPMutex       sync.RWMutex
	crashActualLRPArgsForCall []struct {
		logger      lager.Logger
		key         *models.ActualLRPKey
		instanceKey *models.ActualLRPInstanceKey
		crashReason string
	}
	crashActualLRPReturns struct {
		result1 *models.ActualLRPGroup
		result2 *models.ActualLRPGroup
		result3 bool
		result4 error
	}
	crashActualLRPReturnsOnCall map[int]struct {
		result1 *models.ActualLRPGroup
		result2 *models.ActualLRPGroup
		result3 bool
		result4 error
	}
	FailActualLRPStub        func(logger lager.Logger, key *models.ActualLRPKey, placementError string) (before *models.ActualLRPGroup, after *models.ActualLRPGroup, err error)
	failActualLRPMutex       sync.RWMutex
	failActualLRPArgsForCall []struct {
		logger         lager.Logger
		key            *models.ActualLRPKey
		placementError string
	}
	failActualLRPReturns struct {
		result1 *models.ActualLRPGroup
		result2 *models.ActualLRPGroup
		result3 error
	}
	failActualLRPReturnsOnCall map[int]struct {
		result1 *models.ActualLRPGroup
		result2 *models.ActualLRPGroup
		result3 error
	}
	RemoveActualLRPStub        func(logger lager.Logger, processGuid string, index int32, instanceKey *models.ActualLRPInstanceKey) error
	removeActualLRPMutex       sync.RWMutex
	removeActualLRPArgsForCall []struct {
		logger      lager.Logger
		processGuid string
		index       int32
		instanceKey *models.ActualLRPInstanceKey
	}
	removeActualLRPReturns struct {
		result1 error
	}
	removeActualLRPReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeActualLRPDB) ActualLRPGroups(logger lager.Logger, filter models.ActualLRPFilter) ([]*models.ActualLRPGroup, error) {
	fake.actualLRPGroupsMutex.Lock()
	ret, specificReturn := fake.actualLRPGroupsReturnsOnCall[len(fake.actualLRPGroupsArgsForCall)]
	fake.actualLRPGroupsArgsForCall = append(fake.actualLRPGroupsArgsForCall, struct {
		logger lager.Logger
		filter models.ActualLRPFilter
	}{logger, filter})
	fake.recordInvocation("ActualLRPGroups", []interface{}{logger, filter})
	fake.actualLRPGroupsMutex.Unlock()
	if fake.ActualLRPGroupsStub != nil {
		return fake.ActualLRPGroupsStub(logger, filter)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.actualLRPGroupsReturns.result1, fake.actualLRPGroupsReturns.result2
}

func (fake *FakeActualLRPDB) ActualLRPGroupsCallCount() int {
	fake.actualLRPGroupsMutex.RLock()
	defer fake.actualLRPGroupsMutex.RUnlock()
	return len(fake.actualLRPGroupsArgsForCall)
}

func (fake *FakeActualLRPDB) ActualLRPGroupsArgsForCall(i int) (lager.Logger, models.ActualLRPFilter) {
	fake.actualLRPGroupsMutex.RLock()
	defer fake.actualLRPGroupsMutex.RUnlock()
	return fake.actualLRPGroupsArgsForCall[i].logger, fake.actualLRPGroupsArgsForCall[i].filter
}

func (fake *FakeActualLRPDB) ActualLRPGroupsReturns(result1 []*models.ActualLRPGroup, result2 error) {
	fake.ActualLRPGroupsStub = nil
	fake.actualLRPGroupsReturns = struct {
		result1 []*models.ActualLRPGroup
		result2 error
	}{result1, result2}
}

func (fake *FakeActualLRPDB) ActualLRPGroupsReturnsOnCall(i int, result1 []*models.ActualLRPGroup, result2 error) {
	fake.ActualLRPGroupsStub = nil
	if fake.actualLRPGroupsReturnsOnCall == nil {
		fake.actualLRPGroupsReturnsOnCall = make(map[int]struct {
			result1 []*models.ActualLRPGroup
			result2 error
		})
	}
	fake.actualLRPGroupsReturnsOnCall[i] = struct {
		result1 []*models.ActualLRPGroup
		result2 error
	}{result1, result2}
}

func (fake *FakeActualLRPDB) ActualLRPGroupsByProcessGuid(logger lager.Logger, processGuid string) ([]*models.ActualLRPGroup, error) {
	fake.actualLRPGroupsByProcessGuidMutex.Lock()
	ret, specificReturn := fake.actualLRPGroupsByProcessGuidReturnsOnCall[len(fake.actualLRPGroupsByProcessGuidArgsForCall)]
	fake.actualLRPGroupsByProcessGuidArgsForCall = append(fake.actualLRPGroupsByProcessGuidArgsForCall, struct {
		logger      lager.Logger
		processGuid string
	}{logger, processGuid})
	fake.recordInvocation("ActualLRPGroupsByProcessGuid", []interface{}{logger, processGuid})
	fake.actualLRPGroupsByProcessGuidMutex.Unlock()
	if fake.ActualLRPGroupsByProcessGuidStub != nil {
		return fake.ActualLRPGroupsByProcessGuidStub(logger, processGuid)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.actualLRPGroupsByProcessGuidReturns.result1, fake.actualLRPGroupsByProcessGuidReturns.result2
}

func (fake *FakeActualLRPDB) ActualLRPGroupsByProcessGuidCallCount() int {
	fake.actualLRPGroupsByProcessGuidMutex.RLock()
	defer fake.actualLRPGroupsByProcessGuidMutex.RUnlock()
	return len(fake.actualLRPGroupsByProcessGuidArgsForCall)
}

func (fake *FakeActualLRPDB) ActualLRPGroupsByProcessGuidArgsForCall(i int) (lager.Logger, string) {
	fake.actualLRPGroupsByProcessGuidMutex.RLock()
	defer fake.actualLRPGroupsByProcessGuidMutex.RUnlock()
	return fake.actualLRPGroupsByProcessGuidArgsForCall[i].logger, fake.actualLRPGroupsByProcessGuidArgsForCall[i].processGuid
}

func (fake *FakeActualLRPDB) ActualLRPGroupsByProcessGuidReturns(result1 []*models.ActualLRPGroup, result2 error) {
	fake.ActualLRPGroupsByProcessGuidStub = nil
	fake.actualLRPGroupsByProcessGuidReturns = struct {
		result1 []*models.ActualLRPGroup
		result2 error
	}{result1, result2}
}

func (fake *FakeActualLRPDB) ActualLRPGroupsByProcessGuidReturnsOnCall(i int, result1 []*models.ActualLRPGroup, result2 error) {
	fake.ActualLRPGroupsByProcessGuidStub = nil
	if fake.actualLRPGroupsByProcessGuidReturnsOnCall == nil {
		fake.actualLRPGroupsByProcessGuidReturnsOnCall = make(map[int]struct {
			result1 []*models.ActualLRPGroup
			result2 error
		})
	}
	fake.actualLRPGroupsByProcessGuidReturnsOnCall[i] = struct {
		result1 []*models.ActualLRPGroup
		result2 error
	}{result1, result2}
}

func (fake *FakeActualLRPDB) ActualLRPGroupByProcessGuidAndIndex(logger lager.Logger, processGuid string, index int32) (*models.ActualLRPGroup, error) {
	fake.actualLRPGroupByProcessGuidAndIndexMutex.Lock()
	ret, specificReturn := fake.actualLRPGroupByProcessGuidAndIndexReturnsOnCall[len(fake.actualLRPGroupByProcessGuidAndIndexArgsForCall)]
	fake.actualLRPGroupByProcessGuidAndIndexArgsForCall = append(fake.actualLRPGroupByProcessGuidAndIndexArgsForCall, struct {
		logger      lager.Logger
		processGuid string
		index       int32
	}{logger, processGuid, index})
	fake.recordInvocation("ActualLRPGroupByProcessGuidAndIndex", []interface{}{logger, processGuid, index})
	fake.actualLRPGroupByProcessGuidAndIndexMutex.Unlock()
	if fake.ActualLRPGroupByProcessGuidAndIndexStub != nil {
		return fake.ActualLRPGroupByProcessGuidAndIndexStub(logger, processGuid, index)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.actualLRPGroupByProcessGuidAndIndexReturns.result1, fake.actualLRPGroupByProcessGuidAndIndexReturns.result2
}

func (fake *FakeActualLRPDB) ActualLRPGroupByProcessGuidAndIndexCallCount() int {
	fake.actualLRPGroupByProcessGuidAndIndexMutex.RLock()
	defer fake.actualLRPGroupByProcessGuidAndIndexMutex.RUnlock()
	return len(fake.actualLRPGroupByProcessGuidAndIndexArgsForCall)
}

func (fake *FakeActualLRPDB) ActualLRPGroupByProcessGuidAndIndexArgsForCall(i int) (lager.Logger, string, int32) {
	fake.actualLRPGroupByProcessGuidAndIndexMutex.RLock()
	defer fake.actualLRPGroupByProcessGuidAndIndexMutex.RUnlock()
	return fake.actualLRPGroupByProcessGuidAndIndexArgsForCall[i].logger, fake.actualLRPGroupByProcessGuidAndIndexArgsForCall[i].processGuid, fake.actualLRPGroupByProcessGuidAndIndexArgsForCall[i].index
}

func (fake *FakeActualLRPDB) ActualLRPGroupByProcessGuidAndIndexReturns(result1 *models.ActualLRPGroup, result2 error) {
	fake.ActualLRPGroupByProcessGuidAndIndexStub = nil
	fake.actualLRPGroupByProcessGuidAndIndexReturns = struct {
		result1 *models.ActualLRPGroup
		result2 error
	}{result1, result2}
}

func (fake *FakeActualLRPDB) ActualLRPGroupByProcessGuidAndIndexReturnsOnCall(i int, result1 *models.ActualLRPGroup, result2 error) {
	fake.ActualLRPGroupByProcessGuidAndIndexStub = nil
	if fake.actualLRPGroupByProcessGuidAndIndexReturnsOnCall == nil {
		fake.actualLRPGroupByProcessGuidAndIndexReturnsOnCall = make(map[int]struct {
			result1 *models.ActualLRPGroup
			result2 error
		})
	}
	fake.actualLRPGroupByProcessGuidAndIndexReturnsOnCall[i] = struct {
		result1 *models.ActualLRPGroup
		result2 error
	}{result1, result2}
}

func (fake *FakeActualLRPDB) CreateUnclaimedActualLRP(logger lager.Logger, key *models.ActualLRPKey) (after *models.ActualLRPGroup, err error) {
	fake.createUnclaimedActualLRPMutex.Lock()
	ret, specificReturn := fake.createUnclaimedActualLRPReturnsOnCall[len(fake.createUnclaimedActualLRPArgsForCall)]
	fake.createUnclaimedActualLRPArgsForCall = append(fake.createUnclaimedActualLRPArgsForCall, struct {
		logger lager.Logger
		key    *models.ActualLRPKey
	}{logger, key})
	fake.recordInvocation("CreateUnclaimedActualLRP", []interface{}{logger, key})
	fake.createUnclaimedActualLRPMutex.Unlock()
	if fake.CreateUnclaimedActualLRPStub != nil {
		return fake.CreateUnclaimedActualLRPStub(logger, key)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.createUnclaimedActualLRPReturns.result1, fake.createUnclaimedActualLRPReturns.result2
}

func (fake *FakeActualLRPDB) CreateUnclaimedActualLRPCallCount() int {
	fake.createUnclaimedActualLRPMutex.RLock()
	defer fake.createUnclaimedActualLRPMutex.RUnlock()
	return len(fake.createUnclaimedActualLRPArgsForCall)
}

func (fake *FakeActualLRPDB) CreateUnclaimedActualLRPArgsForCall(i int) (lager.Logger, *models.ActualLRPKey) {
	fake.createUnclaimedActualLRPMutex.RLock()
	defer fake.createUnclaimedActualLRPMutex.RUnlock()
	return fake.createUnclaimedActualLRPArgsForCall[i].logger, fake.createUnclaimedActualLRPArgsForCall[i].key
}

func (fake *FakeActualLRPDB) CreateUnclaimedActualLRPReturns(result1 *models.ActualLRPGroup, result2 error) {
	fake.CreateUnclaimedActualLRPStub = nil
	fake.createUnclaimedActualLRPReturns = struct {
		result1 *models.ActualLRPGroup
		result2 error
	}{result1, result2}
}

func (fake *FakeActualLRPDB) CreateUnclaimedActualLRPReturnsOnCall(i int, result1 *models.ActualLRPGroup, result2 error) {
	fake.CreateUnclaimedActualLRPStub = nil
	if fake.createUnclaimedActualLRPReturnsOnCall == nil {
		fake.createUnclaimedActualLRPReturnsOnCall = make(map[int]struct {
			result1 *models.ActualLRPGroup
			result2 error
		})
	}
	fake.createUnclaimedActualLRPReturnsOnCall[i] = struct {
		result1 *models.ActualLRPGroup
		result2 error
	}{result1, result2}
}

func (fake *FakeActualLRPDB) UnclaimActualLRP(logger lager.Logger, key *models.ActualLRPKey) (before *models.ActualLRPGroup, after *models.ActualLRPGroup, err error) {
	fake.unclaimActualLRPMutex.Lock()
	ret, specificReturn := fake.unclaimActualLRPReturnsOnCall[len(fake.unclaimActualLRPArgsForCall)]
	fake.unclaimActualLRPArgsForCall = append(fake.unclaimActualLRPArgsForCall, struct {
		logger lager.Logger
		key    *models.ActualLRPKey
	}{logger, key})
	fake.recordInvocation("UnclaimActualLRP", []interface{}{logger, key})
	fake.unclaimActualLRPMutex.Unlock()
	if fake.UnclaimActualLRPStub != nil {
		return fake.UnclaimActualLRPStub(logger, key)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.unclaimActualLRPReturns.result1, fake.unclaimActualLRPReturns.result2, fake.unclaimActualLRPReturns.result3
}

func (fake *FakeActualLRPDB) UnclaimActualLRPCallCount() int {
	fake.unclaimActualLRPMutex.RLock()
	defer fake.unclaimActualLRPMutex.RUnlock()
	return len(fake.unclaimActualLRPArgsForCall)
}

func (fake *FakeActualLRPDB) UnclaimActualLRPArgsForCall(i int) (lager.Logger, *models.ActualLRPKey) {
	fake.unclaimActualLRPMutex.RLock()
	defer fake.unclaimActualLRPMutex.RUnlock()
	return fake.unclaimActualLRPArgsForCall[i].logger, fake.unclaimActualLRPArgsForCall[i].key
}

func (fake *FakeActualLRPDB) UnclaimActualLRPReturns(result1 *models.ActualLRPGroup, result2 *models.ActualLRPGroup, result3 error) {
	fake.UnclaimActualLRPStub = nil
	fake.unclaimActualLRPReturns = struct {
		result1 *models.ActualLRPGroup
		result2 *models.ActualLRPGroup
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeActualLRPDB) UnclaimActualLRPReturnsOnCall(i int, result1 *models.ActualLRPGroup, result2 *models.ActualLRPGroup, result3 error) {
	fake.UnclaimActualLRPStub = nil
	if fake.unclaimActualLRPReturnsOnCall == nil {
		fake.unclaimActualLRPReturnsOnCall = make(map[int]struct {
			result1 *models.ActualLRPGroup
			result2 *models.ActualLRPGroup
			result3 error
		})
	}
	fake.unclaimActualLRPReturnsOnCall[i] = struct {
		result1 *models.ActualLRPGroup
		result2 *models.ActualLRPGroup
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeActualLRPDB) ClaimActualLRP(logger lager.Logger, processGuid string, index int32, instanceKey *models.ActualLRPInstanceKey) (before *models.ActualLRPGroup, after *models.ActualLRPGroup, err error) {
	fake.claimActualLRPMutex.Lock()
	ret, specificReturn := fake.claimActualLRPReturnsOnCall[len(fake.claimActualLRPArgsForCall)]
	fake.claimActualLRPArgsForCall = append(fake.claimActualLRPArgsForCall, struct {
		logger      lager.Logger
		processGuid string
		index       int32
		instanceKey *models.ActualLRPInstanceKey
	}{logger, processGuid, index, instanceKey})
	fake.recordInvocation("ClaimActualLRP", []interface{}{logger, processGuid, index, instanceKey})
	fake.claimActualLRPMutex.Unlock()
	if fake.ClaimActualLRPStub != nil {
		return fake.ClaimActualLRPStub(logger, processGuid, index, instanceKey)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.claimActualLRPReturns.result1, fake.claimActualLRPReturns.result2, fake.claimActualLRPReturns.result3
}

func (fake *FakeActualLRPDB) ClaimActualLRPCallCount() int {
	fake.claimActualLRPMutex.RLock()
	defer fake.claimActualLRPMutex.RUnlock()
	return len(fake.claimActualLRPArgsForCall)
}

func (fake *FakeActualLRPDB) ClaimActualLRPArgsForCall(i int) (lager.Logger, string, int32, *models.ActualLRPInstanceKey) {
	fake.claimActualLRPMutex.RLock()
	defer fake.claimActualLRPMutex.RUnlock()
	return fake.claimActualLRPArgsForCall[i].logger, fake.claimActualLRPArgsForCall[i].processGuid, fake.claimActualLRPArgsForCall[i].index, fake.claimActualLRPArgsForCall[i].instanceKey
}

func (fake *FakeActualLRPDB) ClaimActualLRPReturns(result1 *models.ActualLRPGroup, result2 *models.ActualLRPGroup, result3 error) {
	fake.ClaimActualLRPStub = nil
	fake.claimActualLRPReturns = struct {
		result1 *models.ActualLRPGroup
		result2 *models.ActualLRPGroup
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeActualLRPDB) ClaimActualLRPReturnsOnCall(i int, result1 *models.ActualLRPGroup, result2 *models.ActualLRPGroup, result3 error) {
	fake.ClaimActualLRPStub = nil
	if fake.claimActualLRPReturnsOnCall == nil {
		fake.claimActualLRPReturnsOnCall = make(map[int]struct {
			result1 *models.ActualLRPGroup
			result2 *models.ActualLRPGroup
			result3 error
		})
	}
	fake.claimActualLRPReturnsOnCall[i] = struct {
		result1 *models.ActualLRPGroup
		result2 *models.ActualLRPGroup
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeActualLRPDB) StartActualLRP(logger lager.Logger, key *models.ActualLRPKey, instanceKey *models.ActualLRPInstanceKey, netInfo *models.ActualLRPNetInfo) (before *models.ActualLRPGroup, after *models.ActualLRPGroup, err error) {
	fake.startActualLRPMutex.Lock()
	ret, specificReturn := fake.startActualLRPReturnsOnCall[len(fake.startActualLRPArgsForCall)]
	fake.startActualLRPArgsForCall = append(fake.startActualLRPArgsForCall, struct {
		logger      lager.Logger
		key         *models.ActualLRPKey
		instanceKey *models.ActualLRPInstanceKey
		netInfo     *models.ActualLRPNetInfo
	}{logger, key, instanceKey, netInfo})
	fake.recordInvocation("StartActualLRP", []interface{}{logger, key, instanceKey, netInfo})
	fake.startActualLRPMutex.Unlock()
	if fake.StartActualLRPStub != nil {
		return fake.StartActualLRPStub(logger, key, instanceKey, netInfo)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.startActualLRPReturns.result1, fake.startActualLRPReturns.result2, fake.startActualLRPReturns.result3
}

func (fake *FakeActualLRPDB) StartActualLRPCallCount() int {
	fake.startActualLRPMutex.RLock()
	defer fake.startActualLRPMutex.RUnlock()
	return len(fake.startActualLRPArgsForCall)
}

func (fake *FakeActualLRPDB) StartActualLRPArgsForCall(i int) (lager.Logger, *models.ActualLRPKey, *models.ActualLRPInstanceKey, *models.ActualLRPNetInfo) {
	fake.startActualLRPMutex.RLock()
	defer fake.startActualLRPMutex.RUnlock()
	return fake.startActualLRPArgsForCall[i].logger, fake.startActualLRPArgsForCall[i].key, fake.startActualLRPArgsForCall[i].instanceKey, fake.startActualLRPArgsForCall[i].netInfo
}

func (fake *FakeActualLRPDB) StartActualLRPReturns(result1 *models.ActualLRPGroup, result2 *models.ActualLRPGroup, result3 error) {
	fake.StartActualLRPStub = nil
	fake.startActualLRPReturns = struct {
		result1 *models.ActualLRPGroup
		result2 *models.ActualLRPGroup
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeActualLRPDB) StartActualLRPReturnsOnCall(i int, result1 *models.ActualLRPGroup, result2 *models.ActualLRPGroup, result3 error) {
	fake.StartActualLRPStub = nil
	if fake.startActualLRPReturnsOnCall == nil {
		fake.startActualLRPReturnsOnCall = make(map[int]struct {
			result1 *models.ActualLRPGroup
			result2 *models.ActualLRPGroup
			result3 error
		})
	}
	fake.startActualLRPReturnsOnCall[i] = struct {
		result1 *models.ActualLRPGroup
		result2 *models.ActualLRPGroup
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeActualLRPDB) CrashActualLRP(logger lager.Logger, key *models.ActualLRPKey, instanceKey *models.ActualLRPInstanceKey, crashReason string) (before *models.ActualLRPGroup, after *models.ActualLRPGroup, shouldRestart bool, err error) {
	fake.crashActualLRPMutex.Lock()
	ret, specificReturn := fake.crashActualLRPReturnsOnCall[len(fake.crashActualLRPArgsForCall)]
	fake.crashActualLRPArgsForCall = append(fake.crashActualLRPArgsForCall, struct {
		logger      lager.Logger
		key         *models.ActualLRPKey
		instanceKey *models.ActualLRPInstanceKey
		crashReason string
	}{logger, key, instanceKey, crashReason})
	fake.recordInvocation("CrashActualLRP", []interface{}{logger, key, instanceKey, crashReason})
	fake.crashActualLRPMutex.Unlock()
	if fake.CrashActualLRPStub != nil {
		return fake.CrashActualLRPStub(logger, key, instanceKey, crashReason)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3, ret.result4
	}
	return fake.crashActualLRPReturns.result1, fake.crashActualLRPReturns.result2, fake.crashActualLRPReturns.result3, fake.crashActualLRPReturns.result4
}

func (fake *FakeActualLRPDB) CrashActualLRPCallCount() int {
	fake.crashActualLRPMutex.RLock()
	defer fake.crashActualLRPMutex.RUnlock()
	return len(fake.crashActualLRPArgsForCall)
}

func (fake *FakeActualLRPDB) CrashActualLRPArgsForCall(i int) (lager.Logger, *models.ActualLRPKey, *models.ActualLRPInstanceKey, string) {
	fake.crashActualLRPMutex.RLock()
	defer fake.crashActualLRPMutex.RUnlock()
	return fake.crashActualLRPArgsForCall[i].logger, fake.crashActualLRPArgsForCall[i].key, fake.crashActualLRPArgsForCall[i].instanceKey, fake.crashActualLRPArgsForCall[i].crashReason
}

func (fake *FakeActualLRPDB) CrashActualLRPReturns(result1 *models.ActualLRPGroup, result2 *models.ActualLRPGroup, result3 bool, result4 error) {
	fake.CrashActualLRPStub = nil
	fake.crashActualLRPReturns = struct {
		result1 *models.ActualLRPGroup
		result2 *models.ActualLRPGroup
		result3 bool
		result4 error
	}{result1, result2, result3, result4}
}

func (fake *FakeActualLRPDB) CrashActualLRPReturnsOnCall(i int, result1 *models.ActualLRPGroup, result2 *models.ActualLRPGroup, result3 bool, result4 error) {
	fake.CrashActualLRPStub = nil
	if fake.crashActualLRPReturnsOnCall == nil {
		fake.crashActualLRPReturnsOnCall = make(map[int]struct {
			result1 *models.ActualLRPGroup
			result2 *models.ActualLRPGroup
			result3 bool
			result4 error
		})
	}
	fake.crashActualLRPReturnsOnCall[i] = struct {
		result1 *models.ActualLRPGroup
		result2 *models.ActualLRPGroup
		result3 bool
		result4 error
	}{result1, result2, result3, result4}
}

func (fake *FakeActualLRPDB) FailActualLRP(logger lager.Logger, key *models.ActualLRPKey, placementError string) (before *models.ActualLRPGroup, after *models.ActualLRPGroup, err error) {
	fake.failActualLRPMutex.Lock()
	ret, specificReturn := fake.failActualLRPReturnsOnCall[len(fake.failActualLRPArgsForCall)]
	fake.failActualLRPArgsForCall = append(fake.failActualLRPArgsForCall, struct {
		logger         lager.Logger
		key            *models.ActualLRPKey
		placementError string
	}{logger, key, placementError})
	fake.recordInvocation("FailActualLRP", []interface{}{logger, key, placementError})
	fake.failActualLRPMutex.Unlock()
	if fake.FailActualLRPStub != nil {
		return fake.FailActualLRPStub(logger, key, placementError)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.failActualLRPReturns.result1, fake.failActualLRPReturns.result2, fake.failActualLRPReturns.result3
}

func (fake *FakeActualLRPDB) FailActualLRPCallCount() int {
	fake.failActualLRPMutex.RLock()
	defer fake.failActualLRPMutex.RUnlock()
	return len(fake.failActualLRPArgsForCall)
}

func (fake *FakeActualLRPDB) FailActualLRPArgsForCall(i int) (lager.Logger, *models.ActualLRPKey, string) {
	fake.failActualLRPMutex.RLock()
	defer fake.failActualLRPMutex.RUnlock()
	return fake.failActualLRPArgsForCall[i].logger, fake.failActualLRPArgsForCall[i].key, fake.failActualLRPArgsForCall[i].placementError
}

func (fake *FakeActualLRPDB) FailActualLRPReturns(result1 *models.ActualLRPGroup, result2 *models.ActualLRPGroup, result3 error) {
	fake.FailActualLRPStub = nil
	fake.failActualLRPReturns = struct {
		result1 *models.ActualLRPGroup
		result2 *models.ActualLRPGroup
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeActualLRPDB) FailActualLRPReturnsOnCall(i int, result1 *models.ActualLRPGroup, result2 *models.ActualLRPGroup, result3 error) {
	fake.FailActualLRPStub = nil
	if fake.failActualLRPReturnsOnCall == nil {
		fake.failActualLRPReturnsOnCall = make(map[int]struct {
			result1 *models.ActualLRPGroup
			result2 *models.ActualLRPGroup
			result3 error
		})
	}
	fake.failActualLRPReturnsOnCall[i] = struct {
		result1 *models.ActualLRPGroup
		result2 *models.ActualLRPGroup
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeActualLRPDB) RemoveActualLRP(logger lager.Logger, processGuid string, index int32, instanceKey *models.ActualLRPInstanceKey) error {
	fake.removeActualLRPMutex.Lock()
	ret, specificReturn := fake.removeActualLRPReturnsOnCall[len(fake.removeActualLRPArgsForCall)]
	fake.removeActualLRPArgsForCall = append(fake.removeActualLRPArgsForCall, struct {
		logger      lager.Logger
		processGuid string
		index       int32
		instanceKey *models.ActualLRPInstanceKey
	}{logger, processGuid, index, instanceKey})
	fake.recordInvocation("RemoveActualLRP", []interface{}{logger, processGuid, index, instanceKey})
	fake.removeActualLRPMutex.Unlock()
	if fake.RemoveActualLRPStub != nil {
		return fake.RemoveActualLRPStub(logger, processGuid, index, instanceKey)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.removeActualLRPReturns.result1
}

func (fake *FakeActualLRPDB) RemoveActualLRPCallCount() int {
	fake.removeActualLRPMutex.RLock()
	defer fake.removeActualLRPMutex.RUnlock()
	return len(fake.removeActualLRPArgsForCall)
}

func (fake *FakeActualLRPDB) RemoveActualLRPArgsForCall(i int) (lager.Logger, string, int32, *models.ActualLRPInstanceKey) {
	fake.removeActualLRPMutex.RLock()
	defer fake.removeActualLRPMutex.RUnlock()
	return fake.removeActualLRPArgsForCall[i].logger, fake.removeActualLRPArgsForCall[i].processGuid, fake.removeActualLRPArgsForCall[i].index, fake.removeActualLRPArgsForCall[i].instanceKey
}

func (fake *FakeActualLRPDB) RemoveActualLRPReturns(result1 error) {
	fake.RemoveActualLRPStub = nil
	fake.removeActualLRPReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeActualLRPDB) RemoveActualLRPReturnsOnCall(i int, result1 error) {
	fake.RemoveActualLRPStub = nil
	if fake.removeActualLRPReturnsOnCall == nil {
		fake.removeActualLRPReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.removeActualLRPReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeActualLRPDB) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.actualLRPGroupsMutex.RLock()
	defer fake.actualLRPGroupsMutex.RUnlock()
	fake.actualLRPGroupsByProcessGuidMutex.RLock()
	defer fake.actualLRPGroupsByProcessGuidMutex.RUnlock()
	fake.actualLRPGroupByProcessGuidAndIndexMutex.RLock()
	defer fake.actualLRPGroupByProcessGuidAndIndexMutex.RUnlock()
	fake.createUnclaimedActualLRPMutex.RLock()
	defer fake.createUnclaimedActualLRPMutex.RUnlock()
	fake.unclaimActualLRPMutex.RLock()
	defer fake.unclaimActualLRPMutex.RUnlock()
	fake.claimActualLRPMutex.RLock()
	defer fake.claimActualLRPMutex.RUnlock()
	fake.startActualLRPMutex.RLock()
	defer fake.startActualLRPMutex.RUnlock()
	fake.crashActualLRPMutex.RLock()
	defer fake.crashActualLRPMutex.RUnlock()
	fake.failActualLRPMutex.RLock()
	defer fake.failActualLRPMutex.RUnlock()
	fake.removeActualLRPMutex.RLock()
	defer fake.removeActualLRPMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeActualLRPDB) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ db.ActualLRPDB = new(FakeActualLRPDB)
